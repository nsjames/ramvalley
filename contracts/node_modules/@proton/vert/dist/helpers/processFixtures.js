"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processFixtures = void 0;
const proton_1 = require("../proton");
const chai_1 = require("chai");
/* Create Contracts and accounts */
const processFixtures = (fixture) => {
    const blockchain = new proton_1.Blockchain();
    const accounts = {};
    for (const contract of fixture.contracts) {
        accounts[contract.name.toString()] = blockchain.createContract(contract.name, contract.path, contract.enableInline);
    }
    for (const account of fixture.accounts) {
        accounts[account] = blockchain.createAccount(account);
    }
    beforeEach(async () => {
        for (const beforeEach of fixture.beforeEach) {
            if (beforeEach.helper === "resetTables") {
                blockchain.resetTables();
            }
        }
    });
    fixture.tests.forEach(test => describe(test.description, () => {
        test.cases.forEach(testCase => it(testCase.title, async () => {
            for (const action of testCase.actions) {
                const promise = accounts[action.contract].actions[action.action](action.data).send(action.authorization);
                if (!action.expectErrorMessage) {
                    await promise;
                }
                else {
                    await promise
                        .then(() => { throw new Error(`Was expecting to fail with ${action.expectErrorMessage}`); })
                        .catch((e) => (0, chai_1.expect)(e.message).to.be.deep.eq(action.expectErrorMessage));
                }
            }
        }));
    }));
};
exports.processFixtures = processFixtures;
//# sourceMappingURL=processFixtures.js.map