"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const chai_1 = require("chai");
const eosio_1 = require("@greymass/eosio");
const blockchain_1 = require("../blockchain");
const bn_1 = require("../bn");
const errors_1 = require("../errors");
/**
 * Initialize
 */
const blockchain = new blockchain_1.Blockchain();
const eosioToken = blockchain.createAccount({
    name: eosio_1.Name.from('eosio.token'),
    wasm: fs_1.default.readFileSync('contracts/eosio.token/eosio.token.wasm'),
    abi: fs_1.default.readFileSync('contracts/eosio.token/eosio.token.abi', 'utf8'),
});
blockchain.createAccount('alice');
blockchain.createAccount('bob');
beforeEach(() => {
    blockchain.resetTables();
});
/**
 * Helpers
 */
const getStat = (symcode) => {
    const symcodeBigInt = (0, bn_1.symbolCodeToBigInt)(eosio_1.Asset.SymbolCode.from(symcode));
    return eosioToken.tables.stat(symcodeBigInt).getTableRow(symcodeBigInt);
};
const getAccount = (accountName, symcode) => {
    const accountBigInt = (0, bn_1.nameToBigInt)(eosio_1.Name.from(accountName));
    const symcodeBigInt = (0, bn_1.symbolCodeToBigInt)(eosio_1.Asset.SymbolCode.from(symcode));
    return eosioToken.tables.accounts(accountBigInt).getTableRow(symcodeBigInt);
};
function currency_stats(supply, max_supply, issuer) {
    return {
        supply, max_supply, issuer,
    };
}
function account(balance) {
    return {
        balance,
    };
}
/**
 * Tests
 */
describe('eos-vm', () => {
    describe('eosio.token', () => {
        it('create', async () => {
            const symcode = 'TKN';
            await eosioToken.actions.create(['alice', `1000.000 ${symcode}`]).send();
            (0, chai_1.expect)(getStat(symcode)).to.be.deep.equal(currency_stats('0.000 TKN', '1000.000 TKN', 'alice'));
        });
        it('create: negative_max_supply', async () => {
            try {
                await eosioToken.actions.create(['alice', '-1000.000 TKN']).send();
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.equal((0, errors_1.protonAssert)('max-supply must be positive'));
            }
        });
        it('create: symbol_already_exists', async () => {
            const action = eosioToken.actions.create(['alice', '100 TKN']);
            await action.send();
            try {
                await action.send();
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.equal((0, errors_1.protonAssert)('token with symbol already exists'));
            }
        });
        it('create: max_supply', async () => {
            const symcode = 'TKN';
            await eosioToken.actions.create(['alice', `4611686018427387903 ${symcode}`]).send();
            (0, chai_1.expect)(getStat(symcode)).to.be.deep.equal(currency_stats('0 TKN', '4611686018427387903 TKN', 'alice'));
            try {
                await eosioToken.actions.create(['alice', '4611686018427387904 NKT']).send();
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.equal((0, errors_1.protonAssert)('invalid supply'));
            }
        });
        it('create: max_decimals', async () => {
            const symcode = 'TKN';
            await eosioToken.actions.create(['alice', `1.000000000000000000 ${symcode}`]).send();
            (0, chai_1.expect)(getStat(symcode)).to.be.deep.equal(currency_stats('0.000000000000000000 TKN', '1.000000000000000000 TKN', 'alice'));
            try {
                await eosioToken.actions.create(['alice', '1.0000000000000000000 NKT']).send();
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.equal('Encoding error at root<create>.maximum_supply<asset>: Invalid asset symbol, precision too large');
            }
        });
        it('issue', async () => {
            const symcode = 'TKN';
            await eosioToken.actions.create(['alice', `1000.000 ${symcode}`]).send();
            await eosioToken.actions.issue(['alice', `500.000 ${symcode}`, 'hola']).send('alice'); // without @active authorization
            (0, chai_1.expect)(getStat(symcode)).to.be.deep.equal(currency_stats('500.000 TKN', '1000.000 TKN', 'alice'));
            (0, chai_1.expect)(getAccount('alice', symcode)).to.be.deep.equal(account('500.000 TKN'));
            try {
                await eosioToken.actions.issue(['alice', '500.001 TKN', 'hola']).send('alice@active');
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.equal((0, errors_1.protonAssert)('quantity exceeds available supply'));
            }
            try {
                await eosioToken.actions.issue(['alice', '-1.000 TKN', 'hola']).send('alice@active');
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.equal((0, errors_1.protonAssert)('must issue positive quantity'));
            }
            // Check whether action succeeds without exceptions
            await eosioToken.actions.issue(['alice', '1.000 TKN', 'hola']).send('alice@active');
        });
        it('transfer', async () => {
            const symcode = 'CERO';
            await eosioToken.actions.create(['alice', `1000 ${symcode}`]).send();
            await eosioToken.actions.issue(['alice', `1000 ${symcode}`, 'hola']).send('alice@active');
            (0, chai_1.expect)(getStat(symcode)).to.be.deep.equal(currency_stats('1000 CERO', '1000 CERO', 'alice'));
            (0, chai_1.expect)(getAccount('alice', symcode)).to.be.deep.equal(account('1000 CERO'));
            await eosioToken.actions.transfer(['alice', 'bob', '300 CERO', 'hola']).send('alice@active');
            (0, chai_1.expect)(getAccount('alice', symcode)).to.be.deep.equal(account('700 CERO'));
            (0, chai_1.expect)(getAccount('bob', symcode)).to.be.deep.equal(account('300 CERO'));
            try {
                await eosioToken.actions.transfer(['alice', 'bob', '701 CERO', 'hola']).send('alice@active');
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.equal((0, errors_1.protonAssert)('overdrawn balance'));
            }
            try {
                await eosioToken.actions.transfer(['alice', 'bob', '-1000 CERO', 'hola']).send('alice@active');
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.equal((0, errors_1.protonAssert)('must transfer positive quantity'));
            }
        });
    });
});
//# sourceMappingURL=blockchain.spec.js.map