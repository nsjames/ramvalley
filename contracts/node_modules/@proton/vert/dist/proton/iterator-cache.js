"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IteratorCache = void 0;
const assert_1 = __importDefault(require("../assert"));
class IteratorCache {
    constructor() {
        this.tableCache = new Map();
        this.endIteratorToTable = new Array();
        this.iteratorToObject = new Array();
        this.objectToIterator = new Map();
    }
    cacheTable(table) {
        for (const [key, value] of this.tableCache) {
            if (table === value[0]) {
                return value[1];
            }
        }
        const ei = this.indexToEndIterator(this.endIteratorToTable.length);
        this.endIteratorToTable.push(table);
        this.tableCache.set(table.id, { 0: table, 1: ei });
        return ei;
    }
    getTable(id) {
        const found = this.tableCache.get(id);
        (0, assert_1.default)(found, 'an invariant was broken, table should be in cache');
        return found[0];
    }
    getEndIteratorByTableId(id) {
        const found = this.tableCache.get(id);
        (0, assert_1.default)(found, 'an invariant was broken, table should be in cache');
        return found[1];
    }
    findTableByEndIterator(ei) {
        (0, assert_1.default)(ei < -1, 'not an end iterator');
        const idx = this.endIteratorToIndex(ei);
        if (idx >= this.endIteratorToTable.length) {
            return undefined;
        }
        return this.endIteratorToTable[idx];
    }
    get(iterator) {
        (0, assert_1.default)(iterator !== -1, 'invalid iterator');
        (0, assert_1.default)(iterator >= 0, 'deference of end iterator');
        (0, assert_1.default)(iterator < this.iteratorToObject.length, 'iterator out of range');
        (0, assert_1.default)(this.iteratorToObject[iterator]);
        return this.iteratorToObject[iterator];
    }
    set(iterator, value) {
        this.iteratorToObject[iterator] = value;
    }
    remove(iterator) {
        (0, assert_1.default)(iterator != -1, 'invalid iterator');
        (0, assert_1.default)(iterator >= 0, 'cannot call remove on end iterators');
        (0, assert_1.default)(iterator < this.iteratorToObject.length, 'iterator out of range');
        const obj = this.iteratorToObject[iterator];
        if (!obj) {
            return;
        }
        this.iteratorToObject[iterator] = undefined;
        this.objectToIterator.delete(obj);
    }
    add(obj) {
        const itr = this.objectToIterator.get(obj);
        if (itr) {
            return itr;
        }
        this.iteratorToObject.push(obj);
        this.objectToIterator.set(obj, this.iteratorToObject.length - 1);
        return this.iteratorToObject.length - 1;
    }
    endIteratorToIndex(ei) {
        return (-ei - 2);
    }
    indexToEndIterator(idx) {
        return -(idx + 2);
    }
}
exports.IteratorCache = IteratorCache;
//# sourceMappingURL=iterator-cache.js.map