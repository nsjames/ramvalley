"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VM = exports.SecondaryKeyConverter = void 0;
const assert_1 = __importDefault(require("../assert"));
const buffer_1 = __importStar(require("../buffer"));
const vert_1 = require("../vert");
const table_1 = require("./table");
const iterator_cache_1 = require("./iterator-cache");
const eosio_1 = require("@greymass/eosio");
const hash_js_1 = require("hash.js");
const js_sha3_1 = require("js-sha3");
const bn_1 = require("./bn");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const blake2_1 = require("../utils/blake2");
const expmod_1 = require("../utils/expmod");
const codeHash_1 = require("../utils/codeHash");
const curve_1 = require("../utils/curve");
const bn128 = require('rustbn.js');
const owner = (0, bn_1.nameToBigInt)(eosio_1.Name.from('owner'));
const active = (0, bn_1.nameToBigInt)(eosio_1.Name.from('active'));
function convertToUnsigned(...values) {
    return values.map(v => BigInt.asUintN(64, v));
}
exports.SecondaryKeyConverter = {
    uint64: {
        from: (buffer) => buffer.readBigUInt64LE(),
        to: (buffer, value) => buffer.writeBigUInt64LE(value),
    },
    uint128: {
        from: (buffer) => {
            const low = buffer.readBigUInt64LE(0);
            const high = buffer.readBigUInt64LE(8);
            return (high << 64n) | low;
        },
        to: (buffer, value) => {
            buffer.writeBigUInt64LE(value & BigInt.asUintN(64, -1n), 0);
            buffer.writeBigUInt64LE(value >> 64n, 8);
        },
    },
    int128: {
        from: (buffer) => {
            const low = buffer.readBigUInt64LE(0);
            const high = buffer.readBigUInt64LE(8);
            const int = (high << 64n) | low;
            return BigInt.asIntN(128, int);
        },
        to: (buffer, value) => {
            buffer.writeBigUInt64LE(value, 0);
            buffer.writeBigUInt64LE(value >> 64n, 8);
        },
    },
    checksum256: {
        from: (buffer) => {
            const low = buffer.slice(0, 16);
            const high = buffer.slice(16, 32);
            return buffer_1.default.concat([low.reverse(), high.reverse()]);
        },
        to: (buffer, value) => {
            const low = value.slice(0, 16);
            const high = value.slice(16, 32);
            buffer.set(buffer_1.default.concat([low.reverse(), high.reverse()]));
        },
    },
    double: {
        from: (buffer) => buffer.readDoubleLE(),
        to: (buffer, value) => buffer.writeDoubleLE(value),
    },
    /*
    TODO
    LongDouble: {
    },
    */
};
class EosioExitResult extends Error {
    constructor(value) {
        super('eosio_exit: ' + value.toString());
        Object.setPrototypeOf(this, EosioExitResult);
    }
}
class VM extends vert_1.Vert {
    static from(wasm, bc) {
        if (wasm instanceof VM) {
            return wasm;
        }
        return new VM(wasm, bc);
    }
    constructor(wasm, bc) {
        const imports = {
            env: {
                // action
                read_action_data: (msg, len) => {
                    vert_1.log.debug('read_action_data');
                    if (!len) {
                        return this.context.data.length;
                    }
                    const size = Math.min(len, this.context.data.length);
                    buffer_1.default.from_(this.memory.buffer, msg, len).set(this.context.data.subarray(0, size));
                    return size;
                },
                action_data_size: () => {
                    vert_1.log.debug('action_data_size');
                    return this.context.data.length;
                },
                require_auth: (_name) => {
                    const [name] = convertToUnsigned(_name);
                    vert_1.log.debug(`require_auth: ${(0, bn_1.bigIntToName)(name)}`);
                    let hasAuth = false;
                    for (const auth of this.context.authorization) {
                        if ((0, bn_1.nameToBigInt)(auth.actor) === name) {
                            const permission = (0, bn_1.nameToBigInt)(auth.permission);
                            if (permission === active || permission === owner) {
                                hasAuth = true;
                                break;
                            }
                        }
                    }
                    (0, assert_1.default)(hasAuth, `missing required authority ${(0, bn_1.bigIntToName)(name)}`);
                },
                has_auth: (_name) => {
                    const [name] = convertToUnsigned(_name);
                    let hasAuth = false;
                    for (const auth of this.context.authorization) {
                        if ((0, bn_1.nameToBigInt)(auth.actor) === name) {
                            const perm = (0, bn_1.nameToBigInt)(auth.permission);
                            if (perm === active || perm === owner) {
                                hasAuth = true;
                                break;
                            }
                        }
                    }
                    vert_1.log.debug(`has_auth: ${(0, bn_1.bigIntToName)(name)} = ${hasAuth}`);
                    return hasAuth;
                },
                require_auth2: (_name, _permission) => {
                    const [name, permission] = convertToUnsigned(_name, _permission);
                    vert_1.log.debug(`require_auth2: ${(0, bn_1.bigIntToName)(name)}@${(0, bn_1.bigIntToName)(permission)}`);
                    let hasAuth = false;
                    for (const auth of this.context.authorization) {
                        if ((0, bn_1.nameToBigInt)(auth.actor) === name) {
                            const perm = (0, bn_1.nameToBigInt)(auth.permission);
                            if (perm === permission) {
                                hasAuth = true;
                                break;
                            }
                        }
                    }
                    (0, assert_1.default)(hasAuth, `missing required authority ${(0, bn_1.bigIntToName)(name)}@${(0, bn_1.bigIntToName)(permission)}`);
                },
                is_account: (name) => {
                    const [accountNameBigInt] = convertToUnsigned(name);
                    const accountName = (0, bn_1.bigIntToName)(accountNameBigInt);
                    vert_1.log.debug(`is_account: ${accountName} = ${!!this.bc.getAccount(accountName)}`);
                    return !!this.bc.getAccount(accountName);
                },
                get_code_hash: (_accountName, _structVersion, _packedResult) => {
                    const [accountName] = convertToUnsigned(_accountName);
                    const account = this.bc.getAccount((0, bn_1.bigIntToName)(accountName));
                    const codeHashResult = eosio_1.Serializer.encode({
                        object: {
                            struct_version: Math.min(0, _structVersion),
                            code_sequence: account ? account.codeSequence : 0,
                            code_hash: account && account.wasm
                                ? eosio_1.Checksum256.hash(account.wasm)
                                : new eosio_1.Checksum256(new Uint8Array(new Array(32).fill(0))),
                            vm_type: 0,
                            vm_version: 0
                        },
                        type: codeHash_1.CodeHashResult,
                    });
                    buffer_1.default
                        .from_(this.memory.buffer, _packedResult, codeHashResult.array.length)
                        .set(codeHashResult.array);
                    return codeHashResult.array.length;
                },
                require_recipient: (name) => {
                    const [accountNameBigInt] = convertToUnsigned(name);
                    const accountName = (0, bn_1.bigIntToName)(accountNameBigInt);
                    vert_1.log.debug(`require_recipient: ${accountName}`);
                    const account = this.bc.getAccount(accountName);
                    if (!account) {
                        throw new Error(`Account ${accountName} missing for require_recipient`);
                    }
                    const hasRecipient = this.bc.actionTraces.find(n => n.isNotification && n.receiver === account && n.actionOrdinal === this.context.actionOrdinal);
                    if (hasRecipient) {
                        vert_1.log.debug('Skip notification: duplicate');
                        return;
                    }
                    if (!account.isContract) {
                        vert_1.log.debug(`Skip notification: ${accountName} is not a contract`);
                        return;
                    }
                    if (account.name.equals(this.context.receiver.name)) {
                        vert_1.log.debug(`Skip notification: cannot notify self`);
                        return;
                    }
                    vert_1.log.debug(`-> Current: ${this.context.receiver.name}::${this.context.action}`);
                    vert_1.log.debug(`-> Notify Action: ${account.name}::${this.context.action}`);
                    vert_1.log.debug(`-> Notify Data Size: ${this.context.data.length}`);
                    const context = new VM.Context({
                        receiver: account,
                        firstReceiver: this.context.isNotification ? this.context.firstReceiver : this.context.receiver,
                        action: this.context.action,
                        data: this.context.data,
                        authorization: [],
                        decodedData: this.context.decodedData,
                        actionOrdinal: this.context.actionOrdinal
                    });
                    this.context.notificationsQueue.push(context);
                },
                send_inline: (action, size) => {
                    vert_1.log.debug('send_inline');
                    const inlineBuffer = buffer_1.default.from_(this.memory.buffer, action, size);
                    const decodedAction = eosio_1.Serializer.decode({
                        data: inlineBuffer,
                        type: eosio_1.Action,
                    });
                    vert_1.log.debug(`-> Current: ${this.context.receiver.name}::${this.context.action}`);
                    vert_1.log.debug(`-> Inline Action: ${decodedAction.account}::${decodedAction.name}`);
                    vert_1.log.debug(`-> Authority: ${decodedAction.authorization}`);
                    vert_1.log.debug(`-> Inline Action Size: ${decodedAction.data.array.length}`);
                    // Check contract exists
                    const contract = this.bc.getAccount(decodedAction.account);
                    if (!contract || !contract.isContract) {
                        throw new Error(`Contract ${decodedAction.account} is missing for inline action`);
                    }
                    if (contract.actions[decodedAction.name.toString()]) {
                        const context = new VM.Context({
                            sender: this.context.receiver.name,
                            receiver: contract,
                            firstReceiver: contract,
                            action: decodedAction.name,
                            data: decodedAction.data.array.slice(),
                            decodedData: decodedAction.decodeData(contract.abi),
                            authorization: decodedAction.authorization
                        });
                        this.context.actionsQueue.push(context);
                    }
                },
                send_context_free_inline: (action, size) => {
                    vert_1.log.debug('send_context_free_inline');
                    // TODO
                    throw new Error('send_context_free_inline is not implemented');
                },
                publication_time: () => {
                    vert_1.log.debug('publication_time');
                    // TODO
                    throw new Error('publication_time is not implemented: Deferred TXs are deprecated');
                    return 0n;
                },
                current_receiver: () => {
                    vert_1.log.debug('current_receiver');
                    return BigInt.asIntN(64, this.context.receiver.toBigInt());
                },
                set_action_return_value: (value, size) => {
                    vert_1.log.debug('set_action_return_value');
                    this.context.returnValue = buffer_1.default.from_(this.memory.buffer, value, size);
                },
                // chain
                get_active_producers: (producers, len) => {
                    vert_1.log.debug('get_active_producers');
                    return 0;
                },
                // crypto
                assert_sha256: (data, len, hash) => {
                    vert_1.log.debug('assert_sha256');
                    const result = new Uint8Array((0, hash_js_1.sha256)().update(buffer_1.default.from_(this.memory.buffer, data, len)).digest());
                    if (buffer_1.default.compare(result, buffer_1.default.from_(this.memory.buffer, hash, 32))) {
                        throw new Error('hash mismatch');
                    }
                },
                assert_sha1: (data, len, hash) => {
                    vert_1.log.debug('assert_sha1');
                    const result = new Uint8Array((0, hash_js_1.sha1)().update(buffer_1.default.from_(this.memory.buffer, data, len)).digest());
                    if (buffer_1.default.compare(result, buffer_1.default.from_(this.memory.buffer, hash, 20))) {
                        throw new Error('hash mismatch');
                    }
                },
                assert_sha512: (data, len, hash) => {
                    vert_1.log.debug('assert_sha512');
                    const result = new Uint8Array((0, hash_js_1.sha512)().update(buffer_1.default.from_(this.memory.buffer, data, len)).digest());
                    if (buffer_1.default.compare(result, buffer_1.default.from_(this.memory.buffer, hash, 64))) {
                        throw new Error('hash mismatch');
                    }
                },
                assert_ripemd160: (data, len, hash) => {
                    vert_1.log.debug('assert_ripemd160');
                    const result = new Uint8Array((0, hash_js_1.ripemd160)().update(buffer_1.default.from_(this.memory.buffer, data, len)).digest());
                    if (buffer_1.default.compare(result, buffer_1.default.from_(this.memory.buffer, hash, 20))) {
                        throw new Error('hash mismatch');
                    }
                },
                sha256: (data, len, hash) => {
                    vert_1.log.debug('sha256');
                    buffer_1.default.from_(this.memory.buffer, hash, 32).set(new Uint8Array((0, hash_js_1.sha256)().update(buffer_1.default.from_(this.memory.buffer, data, len)).digest()));
                },
                sha1: (data, len, hash) => {
                    vert_1.log.debug('sha1');
                    buffer_1.default.from_(this.memory.buffer, hash, 20).set(new Uint8Array((0, hash_js_1.sha1)().update(buffer_1.default.from_(this.memory.buffer, data, len)).digest()));
                },
                sha512: (data, len, hash) => {
                    vert_1.log.debug('sha512');
                    buffer_1.default.from_(this.memory.buffer, hash, 64).set(new Uint8Array((0, hash_js_1.sha512)().update(buffer_1.default.from_(this.memory.buffer, data, len)).digest()));
                },
                ripemd160: (data, len, hash) => {
                    vert_1.log.debug('ripemd160');
                    buffer_1.default.from_(this.memory.buffer, hash, 20).set(new Uint8Array((0, hash_js_1.ripemd160)().update(buffer_1.default.from_(this.memory.buffer, data, len)).digest()));
                },
                sha3: (data, datalen, hash, hashlen, keccak) => {
                    vert_1.log.debug('sha3');
                    const digestFunc = keccak ? js_sha3_1.keccak256 : js_sha3_1.sha3_256;
                    const inputBuffer = buffer_1.default.from_(this.memory.buffer, data, datalen);
                    buffer_1.default
                        .from_(this.memory.buffer, hash, hashlen)
                        .set(new Uint8Array(digestFunc.update(inputBuffer).digest()));
                },
                blake2_f: (_rounds, _h, _hlen, _m, _mlen, _t0, _t0len, _t1, _t1len, _final, _result, _resultlen) => {
                    vert_1.log.debug('blake2_f');
                    const rounds = _rounds;
                    const f = _final;
                    const hRaw = buffer_1.default.from_(this.memory.buffer, _h, _hlen);
                    const mRaw = buffer_1.default.from_(this.memory.buffer, _m, _mlen);
                    const t0Raw = buffer_1.default.from_(this.memory.buffer, _t0, _t0len);
                    const t1Raw = buffer_1.default.from_(this.memory.buffer, _t1, _t1len);
                    const h = new Uint32Array(16);
                    for (let i = 0; i < 16; i++) {
                        h[i] = hRaw.readUInt32LE(i * 4);
                    }
                    const m = new Uint32Array(32);
                    for (let i = 0; i < 32; i++) {
                        m[i] = mRaw.readUInt32LE(i * 4);
                    }
                    const t = new Uint32Array(4);
                    for (let i = 0; i < 2; i++) {
                        t[i] = t0Raw.readUInt32LE(i * 4);
                    }
                    for (let i = 0; i < 2; i++) {
                        t[i + 2] = t1Raw.readUInt32LE(i * 4);
                    }
                    (0, blake2_1.F)(h, m, t, Boolean(f), rounds);
                    const output = buffer_1.default.alloc(64);
                    for (let i = 0; i < 16; i++) {
                        output.writeUInt32LE(h[i], i * 4);
                    }
                    buffer_1.default
                        .from_(this.memory.buffer, _result, _resultlen)
                        .set(output);
                },
                alt_bn128_add: (_op1, _op1len, _op2, _op2len, _result, _resultlen) => {
                    const op1Raw = buffer_1.default.from_(this.memory.buffer, _op1, _op1len);
                    const op2Raw = buffer_1.default.from_(this.memory.buffer, _op2, _op2len);
                    const input = buffer_1.default.concat([op1Raw, op2Raw]);
                    vert_1.log.debug(`alt_bn128_add: 
          Op1x:
            ${(0, buffer_1.bufferToBigInt)(buffer_1.default.from_(op1Raw.slice(0, 32)))}
            ${buffer_1.default.from_(op1Raw.slice(0, 32)).toString('hex')}
          Op1y:
            ${(0, buffer_1.bufferToBigInt)(buffer_1.default.from_(op1Raw.slice(32)))}
            ${buffer_1.default.from_(op1Raw.slice(32)).toString('hex')}
          Op2x:
            ${(0, buffer_1.bufferToBigInt)(buffer_1.default.from_(op2Raw.slice(0, 32)))}
            ${buffer_1.default.from_(op2Raw.slice(0, 32)).toString('hex')}
          Op2y:
            ${(0, buffer_1.bufferToBigInt)(buffer_1.default.from_(op2Raw.slice(32)))}
            ${buffer_1.default.from_(op2Raw.slice(32)).toString('hex')}
          `);
                    try {
                        const result = bn128.add(input);
                        if (result.length !== 64) {
                            return -1;
                        }
                        buffer_1.default
                            .from_(this.memory.buffer, _result, _resultlen)
                            .set(result);
                        return 0;
                    }
                    catch (e) {
                        return -1;
                    }
                },
                alt_bn128_mul: (_g1, _g1len, _scalar, _scalarlen, _result, _resultlen) => {
                    const g1Raw = buffer_1.default.from_(this.memory.buffer, _g1, _g1len);
                    const scalarRaw = buffer_1.default.from_(this.memory.buffer, _scalar, _scalarlen);
                    const input = buffer_1.default.concat([g1Raw, scalarRaw]);
                    vert_1.log.debug(`alt_bn128_mul: 
            G1x:
              ${(0, buffer_1.bufferToBigInt)(buffer_1.default.from_(g1Raw.slice(0, 32)))}
              ${buffer_1.default.from_(g1Raw.slice(0, 32)).toString('hex')}
            G1y:
              ${(0, buffer_1.bufferToBigInt)(buffer_1.default.from_(g1Raw.slice(32)))}
              ${buffer_1.default.from_(g1Raw.slice(32)).toString('hex')}
            Scalar:
              ${(0, buffer_1.bufferToBigInt)(scalarRaw)}
              ${scalarRaw.toString('hex')}
            `);
                    try {
                        const result = bn128.mul(input);
                        if (result.length !== 64) {
                            return -1;
                        }
                        buffer_1.default
                            .from_(this.memory.buffer, _result, _resultlen)
                            .set(result);
                        return 0;
                    }
                    catch (e) {
                        return -1;
                    }
                },
                alt_bn128_pair: (_pairs, _pairslen) => {
                    vert_1.log.debug(`alt_bn128_pair`);
                    const pairsRaw = buffer_1.default.from_(this.memory.buffer, _pairs, _pairslen);
                    try {
                        const result = bn128.pairing(pairsRaw);
                        if (result.length !== 32) {
                            return -1;
                        }
                        return result[31] === 0 ? 1 : 0;
                    }
                    catch (e) {
                        return -1;
                    }
                },
                mod_exp: (_base, _baselen, _exp, _explen, _mod, _modlen, _result, _resultlen) => {
                    vert_1.log.debug(`mod_exp`);
                    const baseRaw = buffer_1.default.from_(this.memory.buffer, _base, _baselen);
                    const expRaw = buffer_1.default.from_(this.memory.buffer, _exp, _explen);
                    const modRaw = buffer_1.default.from_(this.memory.buffer, _mod, _modlen);
                    const B = (0, buffer_1.bufferToBigInt)(baseRaw);
                    const E = (0, buffer_1.bufferToBigInt)(expRaw);
                    const M = (0, buffer_1.bufferToBigInt)(modRaw);
                    if (M === BigInt(0)) {
                        return -1;
                    }
                    try {
                        const result = (0, expmod_1.expmod)(B, E, M);
                        const resultBuffer = (0, buffer_1.readBufferFromBigInt)(result, 32, false);
                        buffer_1.default
                            .from_(this.memory.buffer, _result, _resultlen)
                            .set(resultBuffer);
                        return 0;
                    }
                    catch (e) {
                        return -1;
                    }
                },
                recover_key: (digest, sig, siglen, pub, publen) => {
                    vert_1.log.debug('recover_key');
                    const signature = buffer_1.default.from_(this.memory.buffer, sig, siglen);
                    (0, assert_1.default)(signature[0] === 0, 'unsupported signature type');
                    const publicKey = eosio_1.Signature.from({
                        type: 'K1',
                        r: signature.slice(2, 34),
                        s: signature.slice(34, 66),
                        recid: (signature[1] - 27) & 0x3,
                    }).recoverDigest(buffer_1.default.from_(this.memory.buffer, digest, 32)).data.array;
                    const size = Math.min(publicKey.length + 1, publen);
                    buffer_1.default.from_(this.memory.buffer, pub, publen).set(publicKey.slice(0, size - 1), 1);
                    return size;
                },
                assert_recover_key: (digest, sig, siglen, pub, publen) => {
                    vert_1.log.debug('assert_recover_key');
                    const signature = buffer_1.default.from_(this.memory.buffer, sig, siglen);
                    (0, assert_1.default)(signature[0] === 0, 'unsupported signature type');
                    const publicKey = buffer_1.default.from_(this.memory.buffer, pub, publen);
                    (0, assert_1.default)(publicKey[0] === 0, 'unsupported public key type');
                    (0, assert_1.default)(eosio_1.Signature.from({
                        type: 'K1',
                        r: signature.slice(2, 34),
                        s: signature.slice(34, 66),
                        recid: (signature[1] - 27) & 0x3,
                    }).verifyDigest(buffer_1.default.from_(this.memory.buffer, digest, 32), eosio_1.PublicKey.from({ type: 'K1', compressed: publicKey.slice(1) })), 'recovered key is different from expected one');
                },
                k1_recover: (sig, siglen, dig, diglen, pub, publen) => {
                    vert_1.log.debug('k1_recover');
                    const sigBuffer = buffer_1.default.from_(this.memory.buffer, sig, siglen);
                    const digBuffer = buffer_1.default.from_(this.memory.buffer, dig, diglen);
                    if (sigBuffer.length != 65 || digBuffer.length != 32) {
                        return -1;
                    }
                    let recid = sigBuffer[0];
                    if (recid < 27 || recid >= 35) {
                        return -1;
                    }
                    recid = (recid - 27) & 0x3;
                    try {
                        const signature = eosio_1.Signature.from({
                            type: 'K1',
                            r: sigBuffer.slice(1, 33),
                            s: sigBuffer.slice(33, 65),
                            recid,
                        });
                        const publicKey = (0, curve_1.recoverUncompressedDigest)(signature, digBuffer);
                        buffer_1.default.from_(this.memory.buffer, pub, publen).set(publicKey.slice(0, publen));
                        return 0;
                    }
                    catch (e) {
                        return -1;
                    }
                },
                // db
                db_store_i64: (_scope, _table, _payer, _id, data, len) => {
                    const [scope, table, payer, id] = convertToUnsigned(_scope, _table, _payer, _id);
                    vert_1.log.debug(`db_store_i64: Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | ID ${id}`);
                    const tab = this.findOrCreateTable(this.context.receiver.name, (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table), (0, bn_1.bigIntToName)(payer));
                    (0, assert_1.default)(payer !== 0n, 'must specify a valid account to pay for new record');
                    (0, assert_1.default)(!tab.has(id), 'key uniqueness violation');
                    const kv = new table_1.KeyValueObject({
                        tableId: tab.id,
                        primaryKey: id,
                        payer,
                        value: new Uint8Array(this.memory.buffer, data, len).slice()
                    });
                    kv.tableId = tab.id;
                    kv.primaryKey = id;
                    kv.payer = payer;
                    kv.value = new Uint8Array(this.memory.buffer, data, len).slice();
                    tab.set(id, kv);
                    this.kvCache.cacheTable(tab);
                    return this.kvCache.add(kv);
                },
                db_update_i64: (iterator, _payer, data, len) => {
                    vert_1.log.debug(`db_update_i64: Iterator ${iterator}`);
                    const payer = BigInt.asUintN(64, _payer);
                    const kvPrev = this.kvCache.get(iterator);
                    const kv = kvPrev.clone();
                    const tab = this.kvCache.getTable(kv.tableId);
                    (0, assert_1.default)(tab.code === this.context.receiver.toBigInt(), 'db access violation');
                    if (payer) {
                        kv.payer = payer;
                    }
                    kv.value = new Uint8Array(this.memory.buffer, data, len).slice();
                    tab.set(kv.primaryKey, kv);
                    this.kvCache.set(iterator, kv);
                },
                db_remove_i64: (iterator) => {
                    vert_1.log.debug(`db_remove_i64: Iterator ${iterator}`);
                    const kv = this.kvCache.get(iterator);
                    const tab = this.kvCache.getTable(kv.tableId);
                    (0, assert_1.default)(tab.code === this.context.receiver.toBigInt(), 'db access violation');
                    tab.delete(kv.primaryKey);
                    this.kvCache.remove(iterator);
                },
                db_get_i64: (iterator, data, len) => {
                    vert_1.log.debug(`db_get_i64: Iterator ${iterator}`);
                    const kv = this.kvCache.get(iterator);
                    if (!len) {
                        return kv.value.length;
                    }
                    const size = Math.min(len, kv.value.length);
                    buffer_1.default.from_(this.memory.buffer, data, len).set(kv.value.subarray(0, size));
                    return size;
                },
                db_next_i64: (iterator, primary) => {
                    vert_1.log.debug(`db_next_i64: Iterator ${iterator}`);
                    if (iterator < -1)
                        return -1;
                    const kv = this.kvCache.get(iterator);
                    const kvNext = this.bc.store.getTableById(kv.tableId).next(kv.primaryKey);
                    if (!kvNext) {
                        return this.kvCache.getEndIteratorByTableId(kv.tableId);
                    }
                    this.memory.writeUInt64(primary, kvNext.primaryKey);
                    return this.kvCache.add(kvNext);
                },
                db_previous_i64: (iterator, primary) => {
                    vert_1.log.debug(`db_previous_i64: Iterator ${iterator}`);
                    if (iterator < -1) {
                        const tab = this.kvCache.findTableByEndIterator(iterator);
                        (0, assert_1.default)(tab, 'not a valid end iterator');
                        const kv = tab.penultimate();
                        if (!kv)
                            return -1;
                        this.memory.writeUInt64(primary, kv.primaryKey);
                        return this.kvCache.add(kv);
                    }
                    const kv = this.kvCache.get(iterator);
                    const kvPrev = this.bc.store.getTableById(kv.tableId).prev(kv.primaryKey);
                    if (!kvPrev) {
                        return -1;
                    }
                    this.memory.writeUInt64(primary, kvPrev.primaryKey);
                    return this.kvCache.add(kvPrev);
                },
                db_find_i64: (_code, _scope, _table, _id) => {
                    const [code, scope, table, id] = convertToUnsigned(_code, _scope, _table, _id);
                    vert_1.log.debug(`db_find_i64: Contract ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | ID ${id}`);
                    const tab = this.findTable((0, bn_1.bigIntToName)(code), (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table));
                    if (!tab)
                        return -1;
                    const ei = this.kvCache.cacheTable(tab);
                    const kv = tab.get(id);
                    if (!kv)
                        return ei;
                    return this.kvCache.add(kv);
                },
                db_lowerbound_i64: (_code, _scope, _table, _id) => {
                    const [code, scope, table, id] = convertToUnsigned(_code, _scope, _table, _id);
                    vert_1.log.debug(`db_lowerbound_i64: Contract ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | ID ${id}`);
                    const tab = this.bc.store.findTable(code, scope, table);
                    if (!tab) {
                        return -1;
                    }
                    const ei = this.kvCache.cacheTable(tab);
                    const kv = tab.lowerbound(id);
                    if (!kv) {
                        return ei;
                    }
                    return this.kvCache.add(kv);
                },
                db_upperbound_i64: (_code, _scope, _table, _id) => {
                    const [code, scope, table, id] = convertToUnsigned(_code, _scope, _table, _id);
                    vert_1.log.debug(`db_upperbound_i64: Contract ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | ID ${id}`);
                    const tab = this.bc.store.findTable(code, scope, table);
                    if (!tab) {
                        return -1;
                    }
                    const ei = this.kvCache.cacheTable(tab);
                    const kv = tab.upperbound(id);
                    if (!kv) {
                        return ei;
                    }
                    return this.kvCache.add(kv);
                },
                db_end_i64: (_code, _scope, _table) => {
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    vert_1.log.debug(`db_end_i64: Contract ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)}`);
                    const tab = this.findTable((0, bn_1.bigIntToName)(code), (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table));
                    if (!tab)
                        return -1;
                    return this.kvCache.cacheTable(tab);
                },
                // uint64_t secondary index api
                db_idx64_store: (_scope, _table, _payer, _id, secondary) => {
                    const [scope, table, payer, id] = convertToUnsigned(_scope, _table, _payer, _id);
                    vert_1.log.debug(`db_idx64_store: Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | Payer ${(0, bn_1.bigIntToName)(payer)} | ID ${id}`);
                    const itr = this.genericIndex.store(this.bc.store.idx64, this.idx64, scope, table, payer, id, buffer_1.default.from_(this.memory.buffer, secondary, 8), exports.SecondaryKeyConverter.uint64);
                    return itr;
                },
                db_idx64_update: (iterator, _payer, secondary) => {
                    vert_1.log.debug('db_idx64_update');
                    const payer = BigInt.asUintN(64, _payer);
                    this.genericIndex.update(this.bc.store.idx64, this.idx64, iterator, payer, buffer_1.default.from_(this.memory.buffer, secondary, 8), exports.SecondaryKeyConverter.uint64);
                },
                db_idx64_remove: (iterator) => {
                    vert_1.log.debug('db_idx64_remove');
                    this.genericIndex.remove(this.bc.store.idx64, this.idx64, iterator);
                },
                db_idx64_find_secondary: (_code, _scope, _table, secondary, primary) => {
                    vert_1.log.debug('db_idx64_find_secondary');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.find_secondary(this.bc.store.idx64, this.idx64, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 8), primary, exports.SecondaryKeyConverter.uint64);
                },
                db_idx64_find_primary: (_code, _scope, _table, secondary, _primary) => {
                    vert_1.log.debug('db_idx64_find_primary');
                    const [code, scope, table, primaryKey] = convertToUnsigned(_code, _scope, _table, _primary);
                    return this.genericIndex.find_primary(this.bc.store.idx64, this.idx64, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 8), primaryKey, exports.SecondaryKeyConverter.uint64);
                },
                db_idx64_lowerbound: (_code, _scope, _table, secondary, primary) => {
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    vert_1.log.debug(`db_idx64_lowerbound: Code ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | Secondary ${exports.SecondaryKeyConverter.uint128.from(buffer_1.default.from_(this.memory.buffer, secondary, 16))}`);
                    return this.genericIndex.lowerbound_secondary(this.bc.store.idx64, this.idx64, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 8), primary, exports.SecondaryKeyConverter.uint64);
                },
                db_idx64_upperbound: (_code, _scope, _table, secondary, primary) => {
                    vert_1.log.debug('db_idx64_upperbound');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.upperbound_secondary(this.bc.store.idx64, this.idx64, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 8), primary, exports.SecondaryKeyConverter.uint64);
                },
                db_idx64_end: (_code, _scope, _table) => {
                    vert_1.log.debug('db_idx64_end');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.end_secondary(this.bc.store.idx64, this.idx64, code, scope, table);
                },
                db_idx64_next: (iterator, primary) => {
                    vert_1.log.debug('db_idx64_next');
                    return this.genericIndex.next_secondary(this.bc.store.idx64, this.idx64, iterator, primary);
                },
                db_idx64_previous: (iterator, primary) => {
                    vert_1.log.debug('db_idx64_previous');
                    return this.genericIndex.previous_secondary(this.bc.store.idx64, this.idx64, iterator, primary);
                },
                // uint128_t secondary index api
                db_idx128_store: (_scope, _table, _payer, _id, secondary) => {
                    const [scope, table, payer, id] = convertToUnsigned(_scope, _table, _payer, _id);
                    vert_1.log.debug(`db_idx128_store: Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | ID ${id} | Secondary ${exports.SecondaryKeyConverter.uint128.from(buffer_1.default.from_(this.memory.buffer, secondary, 16))}`);
                    const itr = this.genericIndex.store(this.bc.store.idx128, this.idx128, scope, table, payer, id, buffer_1.default.from_(this.memory.buffer, secondary, 16), exports.SecondaryKeyConverter.uint128);
                    return itr;
                },
                db_idx128_update: (iterator, _payer, secondary) => {
                    vert_1.log.debug(`db_idx128_update: Iterator ${iterator}`);
                    const payer = BigInt.asUintN(64, _payer);
                    this.genericIndex.update(this.bc.store.idx128, this.idx128, iterator, payer, buffer_1.default.from_(this.memory.buffer, secondary, 16), exports.SecondaryKeyConverter.uint128);
                },
                db_idx128_remove: (iterator) => {
                    vert_1.log.debug(`db_idx128_remove: Iterator ${iterator}`);
                    this.genericIndex.remove(this.bc.store.idx128, this.idx128, iterator);
                },
                db_idx128_find_secondary: (_code, _scope, _table, secondary, primary) => {
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    vert_1.log.debug(`db_idx128_find_secondary: Code ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | Secondary ${exports.SecondaryKeyConverter.uint128.from(buffer_1.default.from_(this.memory.buffer, secondary, 16))}`);
                    return this.genericIndex.find_secondary(this.bc.store.idx128, this.idx128, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 16), primary, exports.SecondaryKeyConverter.uint128);
                },
                db_idx128_find_primary: (_code, _scope, _table, secondary, _primary) => {
                    const [code, scope, table, primaryKey] = convertToUnsigned(_code, _scope, _table, _primary);
                    vert_1.log.debug(`db_idx128_find_primary: Code ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | Primary ${primaryKey} | Secondary ${exports.SecondaryKeyConverter.uint128.from(buffer_1.default.from_(this.memory.buffer, secondary, 16))}`);
                    return this.genericIndex.find_primary(this.bc.store.idx128, this.idx128, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 16), primaryKey, exports.SecondaryKeyConverter.uint128);
                },
                db_idx128_lowerbound: (_code, _scope, _table, secondary, primary) => {
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    vert_1.log.debug(`db_idx128_lowerbound: Code ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | Secondary ${exports.SecondaryKeyConverter.uint128.from(buffer_1.default.from_(this.memory.buffer, secondary, 16))}`);
                    return this.genericIndex.lowerbound_secondary(this.bc.store.idx128, this.idx128, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 16), primary, exports.SecondaryKeyConverter.uint128);
                },
                db_idx128_upperbound: (_code, _scope, _table, secondary, primary) => {
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    vert_1.log.debug(`db_idx128_upperbound: Code ${(0, bn_1.bigIntToName)(code)} | Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | Secondary ${exports.SecondaryKeyConverter.uint128.from(buffer_1.default.from_(this.memory.buffer, secondary, 16))}`);
                    return this.genericIndex.upperbound_secondary(this.bc.store.idx128, this.idx128, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 16), primary, exports.SecondaryKeyConverter.uint128);
                },
                db_idx128_end: (_code, _scope, _table) => {
                    vert_1.log.debug('db_idx128_end');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.end_secondary(this.bc.store.idx128, this.idx128, code, scope, table);
                },
                db_idx128_next: (iterator, primary) => {
                    vert_1.log.debug(`db_idx128_next: Iterator ${iterator}`);
                    return this.genericIndex.next_secondary(this.bc.store.idx128, this.idx128, iterator, primary);
                },
                db_idx128_previous: (iterator, primary) => {
                    vert_1.log.debug('db_idx128_previous');
                    return this.genericIndex.previous_secondary(this.bc.store.idx128, this.idx128, iterator, primary);
                },
                // 256-bit secondary index api
                db_idx256_store: (_scope, _table, _payer, _id, data, data_len) => {
                    const [scope, table, payer, id] = convertToUnsigned(_scope, _table, _payer, _id);
                    vert_1.log.debug(`db_idx256_store: Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | ID ${id}`);
                    const itr = this.genericIndex.store(this.bc.store.idx256, this.idx256, scope, table, payer, id, buffer_1.default.from_(this.memory.buffer, data, 32), exports.SecondaryKeyConverter.checksum256);
                    return itr;
                },
                db_idx256_update: (iterator, _payer, data, data_len) => {
                    vert_1.log.debug(`db_idx256_update: Iterator ${iterator} ${buffer_1.default.from_(this.memory.buffer, data, 32).toString('hex')}`);
                    const payer = BigInt.asUintN(64, _payer);
                    this.genericIndex.update(this.bc.store.idx256, this.idx256, iterator, payer, buffer_1.default.from_(this.memory.buffer, data, 32), exports.SecondaryKeyConverter.checksum256);
                },
                db_idx256_remove: (iterator) => {
                    vert_1.log.debug(`db_idx256_remove: Iterator ${iterator}`);
                    this.genericIndex.remove(this.bc.store.idx256, this.idx256, iterator);
                },
                db_idx256_find_secondary: (_code, _scope, _table, data, data_len, primary) => {
                    vert_1.log.debug('db_idx256_find_secondary');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.find_secondary(this.bc.store.idx256, this.idx256, code, scope, table, buffer_1.default.from_(this.memory.buffer, data, 32), primary, exports.SecondaryKeyConverter.checksum256);
                },
                db_idx256_find_primary: (_code, _scope, _table, data, data_len, _primary) => {
                    vert_1.log.debug(`db_idx256_find_primary: Code ${_code} | Scope ${_scope} | Table ${_table} | Primary ${_primary}`);
                    const [code, scope, table, primaryKey] = convertToUnsigned(_code, _scope, _table, _primary);
                    return this.genericIndex.find_primary(this.bc.store.idx256, this.idx256, code, scope, table, buffer_1.default.from_(this.memory.buffer, data, 32), primaryKey, exports.SecondaryKeyConverter.checksum256);
                },
                db_idx256_lowerbound: (_code, _scope, _table, data, data_len, primary) => {
                    vert_1.log.debug('db_idx256_lowerbound');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.lowerbound_secondary(this.bc.store.idx256, this.idx256, code, scope, table, buffer_1.default.from_(this.memory.buffer, data, 32), primary, exports.SecondaryKeyConverter.checksum256);
                },
                db_idx256_upperbound: (_code, _scope, _table, data, data_len, primary) => {
                    vert_1.log.debug('db_idx256_upperbound');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.upperbound_secondary(this.bc.store.idx256, this.idx256, code, scope, table, buffer_1.default.from_(this.memory.buffer, data, 32), primary, exports.SecondaryKeyConverter.checksum256);
                },
                db_idx256_end: (_code, _scope, _table) => {
                    vert_1.log.debug('db_idx256_end');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.end_secondary(this.bc.store.idx256, this.idx256, code, scope, table);
                },
                db_idx256_next: (iterator, primary) => {
                    vert_1.log.debug('db_idx256_next');
                    return this.genericIndex.next_secondary(this.bc.store.idx256, this.idx256, iterator, primary);
                },
                db_idx256_previous: (iterator, primary) => {
                    vert_1.log.debug('db_idx256_previous');
                    return this.genericIndex.previous_secondary(this.bc.store.idx256, this.idx256, iterator, primary);
                },
                // double secondary index api
                db_idx_double_store: (_scope, _table, _payer, _id, secondary) => {
                    const [scope, table, payer, id] = convertToUnsigned(_scope, _table, _payer, _id);
                    vert_1.log.debug(`db_idx_double_store: Scope ${(0, bn_1.bigIntToName)(scope)} | Table ${(0, bn_1.bigIntToName)(table)} | ID: ${id} | Secondary ${exports.SecondaryKeyConverter.double.from(buffer_1.default.from_(this.memory.buffer, secondary, 8))}`);
                    const itr = this.genericIndex.store(this.bc.store.idxDouble, this.idxDouble, scope, table, payer, id, buffer_1.default.from_(this.memory.buffer, secondary, 8), exports.SecondaryKeyConverter.double);
                    return itr;
                },
                db_idx_double_update: (iterator, _payer, secondary) => {
                    vert_1.log.debug('db_idx_double_update');
                    const payer = BigInt.asUintN(64, _payer);
                    this.genericIndex.update(this.bc.store.idxDouble, this.idxDouble, iterator, payer, buffer_1.default.from_(this.memory.buffer, secondary, 8), exports.SecondaryKeyConverter.double);
                },
                db_idx_double_remove: (iterator) => {
                    vert_1.log.debug('db_idx_double_remove');
                    this.genericIndex.remove(this.bc.store.idxDouble, this.idxDouble, iterator);
                },
                db_idx_double_find_secondary: (_code, _scope, _table, secondary, primary) => {
                    vert_1.log.debug('db_idx_double_find_secondary');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.find_secondary(this.bc.store.idxDouble, this.idxDouble, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 8), primary, exports.SecondaryKeyConverter.double);
                },
                db_idx_double_find_primary: (_code, _scope, _table, secondary, _primary) => {
                    vert_1.log.debug('db_idx_double_find_primary');
                    const [code, scope, table, primaryKey] = convertToUnsigned(_code, _scope, _table, _primary);
                    return this.genericIndex.find_primary(this.bc.store.idxDouble, this.idxDouble, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 8), primaryKey, exports.SecondaryKeyConverter.double);
                },
                db_idx_double_lowerbound: (_code, _scope, _table, secondary, primary) => {
                    vert_1.log.debug('db_idx_double_lowerbound');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.lowerbound_secondary(this.bc.store.idxDouble, this.idxDouble, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 8), primary, exports.SecondaryKeyConverter.double);
                },
                db_idx_double_upperbound: (_code, _scope, _table, secondary, primary) => {
                    vert_1.log.debug('db_idx_double_upperbound');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.upperbound_secondary(this.bc.store.idxDouble, this.idxDouble, code, scope, table, buffer_1.default.from_(this.memory.buffer, secondary, 8), primary, exports.SecondaryKeyConverter.double);
                },
                db_idx_double_end: (_code, _scope, _table) => {
                    vert_1.log.debug('db_idx_double_end');
                    const [code, scope, table] = convertToUnsigned(_code, _scope, _table);
                    return this.genericIndex.end_secondary(this.bc.store.idxDouble, this.idxDouble, code, scope, table);
                },
                db_idx_double_next: (iterator, primary) => {
                    vert_1.log.debug('db_idx_double_next');
                    return this.genericIndex.next_secondary(this.bc.store.idxDouble, this.idxDouble, iterator, primary);
                },
                db_idx_double_previous: (iterator, primary) => {
                    vert_1.log.debug('db_idx_double_previous');
                    return this.genericIndex.previous_secondary(this.bc.store.idxDouble, this.idxDouble, iterator, primary);
                },
                // long double secondary index api
                /*
                db_idx_long_double_store: () => {},
                db_idx_long_double_update: () => {},
                db_idx_long_double_remove: () => {},
                db_idx_long_double_find_secondary: () => {},
                db_idx_long_double_find_primary: () => {},
                db_idx_long_double_lowerbound: () => {},
                db_idx_long_double_upperbound: () => {},
                db_idx_long_double_end: () => {},
                db_idx_long_double_next: () => {},
                db_idx_long_double_previous: () => {},
                */
                // permission
                check_transaction_authorization: (txData, txSize, pubkeysData, pubkeysSize, permsData, permsSize) => {
                    vert_1.log.debug('check_transaction_authorization');
                    // TODO
                    throw new Error('check_transaction_authorization is not implemented');
                    return 1;
                },
                check_permission_authorization: (account, permission, pubkeysData, pubkeysSize, permsData, permsSize, delayUs) => {
                    vert_1.log.debug('check_permission_authorization');
                    // TODO
                    throw new Error('check_permission_authorization is not implemented');
                    return 1;
                },
                get_permission_last_used: (account, permission) => {
                    vert_1.log.debug('get_permission_last_used');
                    // TODO
                    throw new Error('get_permission_last_used is not implemented');
                    return 0n;
                },
                get_account_creation_time: (_name) => {
                    vert_1.log.debug('get_account_creation_time');
                    const [name] = convertToUnsigned(_name);
                    const account = this.bc.getAccount((0, bn_1.bigIntToName)(name));
                    if (!account) {
                        throw new Error(`Account ${name} is missing for get_account_creation_time`);
                    }
                    return BigInt(account.creationTime.toMilliseconds()) * 1000n;
                },
                // print
                prints: (msg) => {
                    const str = this.memory.readString(msg);
                    if (str === '$vertPrintStorage') {
                        this.printStorage();
                    }
                    vert_1.log.debug('prints', str);
                    this.bc.console += str;
                },
                prints_l: (msg, len) => {
                    const str = this.memory.readString(msg, len);
                    if (str === '$vertPrintStorage') {
                        this.printStorage();
                    }
                    vert_1.log.debug('prints_l', str);
                    this.bc.console += str;
                },
                printi: (value) => {
                    const str = value.toString();
                    vert_1.log.debug('printi', str);
                    this.bc.console += str;
                },
                printui: (value) => {
                    const str = BigInt.asUintN(64, value).toString();
                    vert_1.log.debug('printui', str);
                    this.bc.console += str;
                },
                printi128: (value) => {
                    const str = this.memory.readInt128(value).toString();
                    vert_1.log.debug('printi128', str);
                    this.bc.console += str;
                },
                printui128: (value) => {
                    const str = this.memory.readUInt128(value).toString();
                    vert_1.log.debug('printui128', str);
                    this.bc.console += str;
                },
                printsf: (value) => {
                    // TODO: print to fit precision
                    const str = value.toString();
                    vert_1.log.debug('printsf', str);
                    this.bc.console += str;
                },
                printdf: (value) => {
                    // TODO: print to fit precision
                    const str = value.toString();
                    vert_1.log.debug('printsdf', str);
                    this.bc.console += str;
                },
                printqf: (value) => {
                    // TODO: print to fit precision
                    const str = value.toString();
                    vert_1.log.debug('printsqf', str);
                    this.bc.console += str;
                },
                printn: (value) => {
                    const str = (0, bn_1.bigIntToName)(value).toString();
                    vert_1.log.debug('printn', str);
                    this.bc.console += str;
                },
                printhex: (data, len) => {
                    const str = this.memory.readHex(data, len);
                    vert_1.log.debug('printhex', str);
                    this.bc.console += str;
                },
                // TODO: privileged APIs
                set_proposed_producers: (data, size) => { return 0n; },
                set_blockchain_parameters_packed: (data, len) => { },
                get_blockchain_parameters_packed: (data, len) => { return 0; },
                // TODO: security_group APIs
                // system
                eosio_assert: (test, msg) => {
                    // log.debug('eosio_assert');
                    if (!test) {
                        throw new Error((0, errors_1.protonAssert)(this.memory.readString(msg)));
                    }
                },
                eosio_assert_message: (test, msg, msg_len) => {
                    // log.debug('eosio_assert_message');
                    if (!test) {
                        throw new Error((0, errors_1.protonAssertMessage)(this.memory.readString(msg, msg_len)));
                    }
                },
                eosio_assert_code: (test, code) => {
                    // log.debug('eosio_assert_code');
                    if (!test) {
                        throw new Error((0, errors_1.protonAssertMessage)((0, errors_1.protonAssertCode)(BigInt.asUintN(64, code))));
                    }
                },
                eosio_exit: (code) => {
                    vert_1.log.debug('eosio_exit');
                    // HACK: throw error to stop wasm execution forcibly
                    throw new EosioExitResult(code);
                },
                get_block_num: () => {
                    vert_1.log.debug(`get_block_num: ${this.bc.blockNum}`);
                    return this.bc.blockNum;
                },
                current_time: () => {
                    vert_1.log.debug('current_time', BigInt(this.bc.timestamp.toMilliseconds()) * 1000n);
                    return BigInt(this.bc.timestamp.toMilliseconds()) * 1000n;
                },
                is_feature_activated: (digest) => {
                    const pf = new Uint8Array(this.memory.buffer, digest, 32);
                    const pfChecksum = buffer_1.default.from_(pf).toString('hex');
                    const isFeatureActivated = this.bc.protocolFeatures.includes(pfChecksum);
                    vert_1.log.debug(`is_feature_activated: ${pfChecksum} ${isFeatureActivated}`);
                    return isFeatureActivated;
                },
                get_sender: () => {
                    vert_1.log.debug('get_sender');
                    return BigInt.asIntN(64, (0, bn_1.nameToBigInt)(this.context.sender));
                },
                // transaction
                send_deferred: (sender, payer, tx, size, replace) => {
                    vert_1.log.debug('send_deferred');
                    // TODO
                    throw new Error('send_deferred is not implemented: Deferred TXs are deprecated');
                },
                cancel_deferred: (sender) => {
                    vert_1.log.debug('cancel_deferred');
                    // TODO
                    throw new Error('cancel_deferred is not implemented: Deferred TXs are deprecated');
                    return 0;
                },
                read_transaction: (data, buffer_size) => {
                    vert_1.log.debug('read_transaction');
                    const trx = eosio_1.Serializer.encode({ object: this.context.transaction }).array;
                    const s = trx.length;
                    if (buffer_size == 0)
                        return s;
                    const copy_size = Math.min(buffer_size, s);
                    const destination = new Uint8Array(this.memory.buffer, data, copy_size);
                    destination.set(trx.slice(0, copy_size));
                    return copy_size;
                },
                transaction_size: () => {
                    return eosio_1.Serializer.encode({ object: this.context.transaction }).array.length;
                },
                tapos_block_num: () => {
                    vert_1.log.debug('tapos_block_num');
                    return this.context.transaction.ref_block_num.toNumber();
                },
                tapos_block_prefix: () => {
                    vert_1.log.debug('tapos_block_prefix');
                    return this.context.transaction.ref_block_prefix.toNumber();
                },
                expiration: () => {
                    vert_1.log.debug('expiration');
                    return this.context.transaction.expiration.value.toNumber();
                },
                get_action: (type, index, buffer, buffer_size) => {
                    vert_1.log.debug('get_action');
                    const trx = this.context.transaction;
                    let action;
                    if (type == 0) {
                        if (index >= trx.context_free_actions.length) {
                            return -1;
                        }
                        action = trx.context_free_actions[index];
                    }
                    else if (type == 1) {
                        if (index >= trx.actions.length) {
                            return -1;
                        }
                        action = trx.actions[index];
                    }
                    if (!action) {
                        throw new Error('action is not found');
                    }
                    const packed = eosio_1.Serializer.encode({ object: action }).array;
                    const ps = packed.length;
                    if (ps <= buffer_size) {
                        const destination = new Uint8Array(this.memory.buffer, buffer, buffer_size);
                        destination.set(packed);
                    }
                    return ps;
                },
                get_context_free_data: (index, buffer, size) => {
                    vert_1.log.debug('get_context_free_data');
                    // TODO
                    throw new Error('get_context_free_data is not implemented');
                    return 0;
                },
                // builtins
                abort: () => {
                    vert_1.log.debug('abort');
                    throw new Error('abort');
                },
                memmove: (dest, src, count) => {
                    // log.debug('memmove');
                    const destination = new Uint8Array(this.memory.buffer, dest, count);
                    const source = new Uint8Array(this.memory.buffer, src, count);
                    destination.set(source);
                    return dest;
                },
                memset: (dest, ch, count) => {
                    // log.debug('memset');
                    const destination = new Uint8Array(this.memory.buffer, dest, count);
                    const source = buffer_1.default.alloc(count, ch);
                    destination.set(source);
                    return dest;
                },
                memcpy: (dest, src, count) => {
                    // log.debug('memcpy');
                    // HACK: imitate copying to overlapped destination
                    if ((dest - src) < count && (dest - src) >= 0) {
                        const cpy = (d, s, c) => {
                            if (c <= 0) {
                                return;
                            }
                            const size = Math.min(d - s, c);
                            const destination = new Uint8Array(this.memory.buffer, d, size);
                            const source = new Uint8Array(this.memory.buffer, s, size);
                            destination.set(source);
                            cpy(d + size, s + size, c - size);
                        };
                        cpy(dest, src, count);
                    }
                    else {
                        const destination = new Uint8Array(this.memory.buffer, dest, count);
                        const source = new Uint8Array(this.memory.buffer, src, count);
                        destination.set(source);
                    }
                    return dest;
                },
                // TODO: compiler-rt APIs
                __ashlti3: () => { throw new Error("Not implemented _ashlti3"); },
                // __ashlti3: (ret: ptr, _low: i64, _high: i64, shift: i32) => {
                //   const [low, high] = convertToUnsigned(_low, _high);
                //   const buffer = Buffer.alloc(16)
                //   buffer.writeBigUInt64LE(low, 0);
                //   buffer.writeBigUInt64LE(high, 8);
                //   const num = SecondaryKeyConverter.int128.from(buffer)
                //   const final = BigInt.asUintN(128, num << BigInt(shift))
                //   const retBuffer = Buffer.from_(this.memory.buffer, ret, 16)
                //   SecondaryKeyConverter.int128.to(retBuffer, final)
                // },
                __ashrti3: () => { throw new Error("Not implemented _ashrti3"); },
                __lshlti3: () => { throw new Error("Not implemented _lshlti3"); },
                __lshrti3: () => { throw new Error("Not implemented _lshrti3"); },
                __divti3: (ret, _la, _ha, _lb, _hb) => {
                    const [la, ha, lb, hb] = convertToUnsigned(_la, _ha, _lb, _hb);
                    let lhs = BigInt(ha);
                    let rhs = BigInt(hb);
                    lhs = BigInt.asUintN(128, lhs << BigInt(64));
                    lhs = BigInt.asUintN(128, lhs | la);
                    rhs = BigInt.asUintN(128, rhs << BigInt(64));
                    rhs = BigInt.asUintN(128, rhs | lb);
                    lhs = BigInt.asUintN(128, lhs / rhs);
                    const retBuffer = buffer_1.default.from_(this.memory.buffer, ret, 16);
                    exports.SecondaryKeyConverter.int128.to(retBuffer, lhs);
                },
                __udivti3: (ret, _la, _ha, _lb, _hb) => {
                    const [la, ha, lb, hb] = convertToUnsigned(_la, _ha, _lb, _hb);
                    let lhs = BigInt(ha);
                    let rhs = BigInt(hb);
                    lhs = BigInt.asUintN(128, lhs << BigInt(64));
                    lhs = BigInt.asUintN(128, lhs | la);
                    rhs = BigInt.asUintN(128, rhs << BigInt(64));
                    rhs = BigInt.asUintN(128, rhs | lb);
                    lhs = BigInt.asUintN(128, lhs / rhs);
                    const retBuffer = buffer_1.default.from_(this.memory.buffer, ret, 16);
                    exports.SecondaryKeyConverter.uint128.to(retBuffer, lhs);
                },
                __multi3: (ret, _la, _ha, _lb, _hb) => {
                    const [la, ha, lb, hb] = convertToUnsigned(_la, _ha, _lb, _hb);
                    let lhs = BigInt(ha);
                    let rhs = BigInt(hb);
                    lhs = BigInt.asUintN(128, lhs << BigInt(64));
                    lhs = BigInt.asUintN(128, lhs | la);
                    rhs = BigInt.asUintN(128, rhs << BigInt(64));
                    rhs = BigInt.asUintN(128, rhs | lb);
                    lhs = BigInt.asUintN(128, lhs * rhs);
                    const retBuffer = buffer_1.default.from_(this.memory.buffer, ret, 16);
                    exports.SecondaryKeyConverter.int128.to(retBuffer, lhs);
                },
                __modti3: (ret, _la, _ha, _lb, _hb) => {
                    const [la, ha, lb, hb] = convertToUnsigned(_la, _ha, _lb, _hb);
                    let lhs = BigInt(ha);
                    let rhs = BigInt(hb);
                    lhs = BigInt.asUintN(128, lhs << BigInt(64));
                    lhs = BigInt.asUintN(128, lhs | la);
                    rhs = BigInt.asUintN(128, rhs << BigInt(64));
                    rhs = BigInt.asUintN(128, rhs | lb);
                    lhs = BigInt.asUintN(128, lhs % rhs);
                    const retBuffer = buffer_1.default.from_(this.memory.buffer, ret, 16);
                    exports.SecondaryKeyConverter.int128.to(retBuffer, lhs);
                },
                __umodti3: (ret, _la, _ha, _lb, _hb) => {
                    const [la, ha, lb, hb] = convertToUnsigned(_la, _ha, _lb, _hb);
                    let lhs = BigInt(ha);
                    let rhs = BigInt(hb);
                    lhs = BigInt.asUintN(128, lhs << BigInt(64));
                    lhs = BigInt.asUintN(128, lhs | la);
                    rhs = BigInt.asUintN(128, rhs << BigInt(64));
                    rhs = BigInt.asUintN(128, rhs | lb);
                    lhs = BigInt.asUintN(128, lhs % rhs);
                    const retBuffer = buffer_1.default.from_(this.memory.buffer, ret, 16);
                    exports.SecondaryKeyConverter.uint128.to(retBuffer, lhs);
                },
                __addtf3: (a, b, c, d, e) => { throw new Error("Not implemented _addtf3: (a: ptr, b: i64, c: i64, d: i64, e: i64)"); },
                __subtf3: (a, b, c, d, e) => { throw new Error("Not implemented _subtf3: (a: ptr, b: i64, c: i64, d: i64, e: i64)"); },
                __multf3: (a, b, c, d, e) => { throw new Error("Not implemented _multf3: (a: ptr, b: i64, c: i64, d: i64, e: i64)"); },
                __divtf3: (a, b, c, d, e) => { throw new Error("Not implemented _divtf3: (a: ptr, b: i64, c: i64, d: i64, e: i64)"); },
                __negtf2: () => { throw new Error("Not implemented _negtf2"); },
                __extendsftf2: (a, b) => { throw new Error("Not implemented _extendsftf2: (a: ptr, b: f32)"); },
                __extenddftf2: (a, b) => { throw new Error("Not implemented _extenddftf2: (a: ptr, b: f64)"); },
                __trunctfdf2: (a, b) => { throw new Error("Not implemented __trunctfdf2"); },
                __trunctfsf2: (a, b) => { throw new Error("Not implemented __trunctfsf2"); },
                __fixtfsi: () => { throw new Error("Not implemented _fixtfsi"); },
                __fixtfdi: () => { throw new Error("Not implemented _fixtfdi"); },
                __fixtfti: () => { throw new Error("Not implemented _fixtfti"); },
                __fixunstfsi: () => { throw new Error("Not implemented _fixunstfsi"); },
                __fixunstfdi: () => { throw new Error("Not implemented _fixunstfdi"); },
                __fixunstfti: () => { throw new Error("Not implemented _fixunstfti"); },
                __fixsfti: () => { throw new Error("Not implemented _fixsfti"); },
                __fixdfti: () => { throw new Error("Not implemented _fixdfti"); },
                __fixunssfti: () => { throw new Error("Not implemented _fixunssfti"); },
                __fixunsdfti: (_a, _b) => {
                    const buf = buffer_1.default.alloc(8);
                    exports.SecondaryKeyConverter.double.to(buf, _b);
                    exports.SecondaryKeyConverter.uint64.from(buf);
                    // console.log(a, b)
                    throw new Error("Not implemented _fixunsdfti");
                },
                __floatsidf: () => { throw new Error("Not implemented _floatsidf"); },
                __floatsitf: (a, b) => { throw new Error("Not implemented _floatsitf: (a: ptr, b: i32)"); },
                __floatditf: () => { throw new Error("Not implemented _floatditf"); },
                __floatunsitf: (a, b) => { throw new Error("Not implemented _floatunsitf: (a: ptr, b: i32)"); },
                __floatunditf: () => { throw new Error("Not implemented _floatunditf"); },
                __floattidf: () => { throw new Error("Not implemented _floattidf"); },
                __floatuntidf: (_la, _ha) => {
                    const [la, ha] = convertToUnsigned(_la, _ha);
                    let lhs = BigInt(ha);
                    lhs = BigInt.asUintN(128, lhs << BigInt(64));
                    lhs = BigInt.asUintN(128, lhs | la);
                    return Number(lhs);
                },
                __cmptf2: () => { throw new Error("Not implemented _cmptf2"); },
                __eqtf2: (a, b, c, d) => { throw new Error("Not implemented __eqtf2"); },
                __netf2: (a, b, c, d) => { throw new Error("Not implemented __netf2"); },
                __getf2: (a, b, c, d) => { throw new Error("Not implemented __getf2"); },
                __gttf2: () => { throw new Error("Not implemented _gttf2"); },
                __letf2: (a, b, c, d) => { throw new Error("Not implemented __letf2"); },
                __lttf2: () => { throw new Error("Not implemented _lttf2"); },
                __unordtf2: () => { throw new Error("Not implemented _unordtf2"); },
            },
        };
        super(imports, wasm);
        // TODO
        this.context = new VM.Context();
        this.kvCache = new iterator_cache_1.IteratorCache();
        this.idx64 = new iterator_cache_1.IteratorCache();
        this.idx128 = new iterator_cache_1.IteratorCache();
        this.idx256 = new iterator_cache_1.IteratorCache();
        this.idxDouble = new iterator_cache_1.IteratorCache();
        this.genericIndex = {
            store: (index, cache, scope, table, payer, id, secondary, conv) => {
                (0, assert_1.default)(payer !== 0n, 'must specify a valid account to pay for new record');
                const tab = this.findOrCreateTable(this.context.receiver.name, (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table), (0, bn_1.bigIntToName)(payer));
                const obj = new table_1.IndexObject({
                    tableId: tab.id,
                    primaryKey: id,
                    secondaryKey: conv.from(secondary),
                    payer,
                });
                index.set(undefined, obj);
                cache.cacheTable(tab);
                return cache.add(obj);
            },
            update: (index, cache, iterator, payer, secondary, conv) => {
                const obj = cache.get(iterator);
                const tab = cache.getTable(obj.tableId);
                (0, assert_1.default)(tab.code === this.context.receiver.toBigInt(), 'db access violation');
                if (payer === 0n) {
                    payer = obj.payer;
                }
                const newObj = obj.clone();
                newObj.secondaryKey = conv.from(secondary);
                newObj.payer = payer;
                index.set(obj, newObj);
                cache.set(iterator, newObj);
            },
            remove: (index, cache, iterator) => {
                const obj = cache.get(iterator);
                const tab = cache.getTable(obj.tableId);
                (0, assert_1.default)(tab.code === this.context.receiver.toBigInt(), 'db access violation');
                index.delete(obj);
                cache.remove(iterator);
            },
            find_secondary: (index, cache, code, scope, table, secondary, primary, conv) => {
                const tab = this.findTable((0, bn_1.bigIntToName)(code), (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table));
                if (!tab) {
                    return -1;
                }
                const ei = cache.cacheTable(tab);
                const obj = index.secondary.get({
                    tableId: tab.id,
                    primaryKey: 0n,
                    secondaryKey: conv.from(secondary),
                    ignorePrimaryKey: true,
                });
                if (!obj) {
                    return ei;
                }
                this.memory.writeUInt64(primary, obj.primaryKey);
                return cache.add(obj);
            },
            lowerbound_secondary: (index, cache, code, scope, table, secondary, primary, conv) => {
                const tab = this.findTable((0, bn_1.bigIntToName)(code), (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table));
                if (!tab) {
                    return -1;
                }
                const ei = cache.cacheTable(tab);
                const obj = index.secondary.lowerbound({
                    tableId: tab.id,
                    primaryKey: 0n,
                    secondaryKey: conv.from(secondary),
                    ignorePrimaryKey: false,
                });
                // console.log(obj)
                if (!obj)
                    return ei;
                this.memory.writeUInt64(primary, obj.primaryKey);
                conv.to(secondary, obj.secondaryKey);
                return cache.add(obj);
            },
            upperbound_secondary: (index, cache, code, scope, table, secondary, primary, conv) => {
                const tab = this.findTable((0, bn_1.bigIntToName)(code), (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table));
                if (!tab) {
                    return -1;
                }
                const ei = cache.cacheTable(tab);
                const obj = index.secondary.upperbound({
                    tableId: tab.id,
                    primaryKey: 0n,
                    secondaryKey: conv.from(secondary),
                    ignorePrimaryKey: true,
                });
                // console.log(obj)
                if (!obj)
                    return ei;
                this.memory.writeUInt64(primary, obj.primaryKey);
                conv.to(secondary, obj.secondaryKey);
                return cache.add(obj);
            },
            end_secondary: (index, cache, code, scope, table) => {
                const tab = this.findTable((0, bn_1.bigIntToName)(code), (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table));
                if (!tab) {
                    return -1;
                }
                return cache.cacheTable(tab);
            },
            next_secondary: (index, cache, iterator, primary) => {
                if (iterator < -1) {
                    return -1;
                }
                const obj = cache.get(iterator);
                const objNext = index.secondary.next(obj);
                if (!objNext) {
                    return cache.getEndIteratorByTableId(obj.tableId);
                }
                this.memory.writeUInt64(primary, objNext.primaryKey);
                return cache.add(objNext);
            },
            previous_secondary: (index, cache, iterator, primary) => {
                if (iterator < -1) {
                    const tab = cache.findTableByEndIterator(iterator);
                    (0, assert_1.default)(tab, 'not a valid end iterator');
                    const obj = index.secondary.penultimate(tab.id);
                    // console.log(obj)
                    if (!obj) {
                        return -1;
                    }
                    this.memory.writeUInt64(primary, obj.primaryKey);
                    return cache.add(obj);
                }
                const obj = cache.get(iterator);
                const objPrev = index.secondary.prev(obj);
                if (!objPrev) {
                    return -1;
                }
                this.memory.writeUInt64(primary, objPrev.primaryKey);
                return cache.add(objPrev);
            },
            find_primary: (index, cache, code, scope, table, secondary, primary, conv) => {
                const tab = this.findTable((0, bn_1.bigIntToName)(code), (0, bn_1.bigIntToName)(scope), (0, bn_1.bigIntToName)(table));
                if (!tab) {
                    return -1;
                }
                const ei = cache.cacheTable(tab);
                const obj = index.get({
                    tableId: tab.id,
                    primaryKey: primary
                });
                if (!obj) {
                    return ei;
                }
                conv.to(secondary, obj.secondaryKey);
                return cache.add(obj);
            },
        };
        this.imports = imports;
        this.bc = bc;
    }
    printStorage() {
        const storage = this.bc.getStorage();
        console.dir(storage, { depth: null });
    }
    findTable(code, scope, table) {
        return this.bc.store.findTable((0, bn_1.nameTypeToBigInt)(code), (0, bn_1.nameTypeToBigInt)(scope), (0, bn_1.nameTypeToBigInt)(table));
    }
    findOrCreateTable(code, scope, table, payer) {
        let tab = this.bc.store.findTable((0, bn_1.nameTypeToBigInt)(code), (0, bn_1.nameTypeToBigInt)(scope), (0, bn_1.nameTypeToBigInt)(table));
        if (!tab) {
            tab = this.bc.store.createTable((0, bn_1.nameTypeToBigInt)(code), (0, bn_1.nameTypeToBigInt)(scope), (0, bn_1.nameTypeToBigInt)(table), (0, bn_1.nameTypeToBigInt)(payer));
        }
        return tab;
    }
    apply(context) {
        this.context = context;
        // Check authorization
        for (const auth of this.context.authorization) {
            // Check actor exists
            const account = this.bc.getAccount(auth.actor);
            if (!account) {
                throw new Error(`Account ${auth.actor} is missing for inline action`);
            }
            // Check permission exists
            const accountPermission = account.permissions.find(permission => permission.perm_name.equals(auth.permission));
            if (!accountPermission) {
                throw new Error(`Account ${auth.actor} has no permission ${auth.permission}`);
            }
            // Inline action
            if (this.context.isInline) {
                const satisfied = (0, utils_1.isAuthoritySatisfied)(accountPermission.required_auth, eosio_1.PermissionLevel.from({
                    actor: this.context.sender,
                    permission: 'eosio.code'
                }));
                if (!satisfied) {
                    throw new Error(`Permission ${auth.actor}@${accountPermission.perm_name} is not satisfied by ${this.context.receiver.name}@eosio.code`);
                }
            }
        }
        // Apply
        try {
            this.instance.exports.apply(this.context.receiver.toBigInt(), this.context.firstReceiver.toBigInt(), (0, bn_1.nameToBigInt)(this.context.action));
        }
        catch (e) {
            throw e;
        }
        finally {
            this.finalize();
        }
    }
    finalize() {
        this.kvCache = new iterator_cache_1.IteratorCache();
        this.idx64 = new iterator_cache_1.IteratorCache();
        this.idx128 = new iterator_cache_1.IteratorCache();
        this.idx256 = new iterator_cache_1.IteratorCache();
        this.idxDouble = new iterator_cache_1.IteratorCache();
    }
}
exports.VM = VM;
(function (VM) {
    class Context {
        constructor(init) {
            this.sender = new eosio_1.Name(eosio_1.UInt64.from(0));
            this.authorization = [];
            this.actionsQueue = [];
            this.notificationsQueue = [];
            Object.assign(this, init);
        }
        get isInline() {
            return !this.sender.equals(new eosio_1.Name(eosio_1.UInt64.from(0)));
        }
        get isNotification() {
            return !this.receiver.name.equals(this.firstReceiver.name);
        }
    }
    VM.Context = Context;
})(VM || (VM = {}));
exports.VM = VM;
//# sourceMappingURL=vm.js.map