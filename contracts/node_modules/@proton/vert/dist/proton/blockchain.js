"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = void 0;
const eosio_1 = require("@greymass/eosio");
const fs = __importStar(require("fs"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const diff_1 = require("../utils/diff");
const lodash_1 = require("lodash");
const table_1 = require("./table");
const account_1 = require("./account");
const vm_1 = require("./vm");
const utils_1 = require("./utils");
const bn_1 = require("./bn");
const color_1 = require("../utils/color");
const colors_1 = __importDefault(require("colors"));
const activatedFeatures_1 = require("../utils/activatedFeatures");
const buffer_1 = __importDefault(require("../buffer"));
class Blockchain {
    constructor({ accounts, timestamp, blockNum, store, } = {}) {
        this.console = '';
        this.actionTraces = [];
        this.executionTraces = [];
        this.protocolFeatures = activatedFeatures_1.ACTIVATED_PROTOCOL_FEATURES;
        // Storage
        this.isStorageDeltasEnabled = false;
        this.accounts = accounts || {};
        this.timestamp = timestamp || eosio_1.TimePoint.fromMilliseconds(0);
        this.blockNum = blockNum || 0;
        this.store = store || new table_1.TableStore();
    }
    applyTransactionActions(transaction, decodedData) {
        let actionOrdinal = -1;
        let executionOrder = -1;
        for (const action of transaction.actions) {
            const contract = this.getAccount(action.account);
            if (!contract || !contract.isContract) {
                throw new Error(`Contract ${action.account} missing for inline action`);
            }
            let context = new vm_1.VM.Context({
                receiver: contract,
                firstReceiver: contract,
                action: action.name,
                data: action.data.array,
                authorization: action.authorization,
                transaction,
                decodedData
            });
            let actionsQueue = [context];
            let notificationsQueue = [];
            while (notificationsQueue.length || actionsQueue.length) {
                // Shift context and increment orders
                if (notificationsQueue.length) {
                    context = notificationsQueue.shift();
                    context.actionOrdinal = actionOrdinal;
                }
                else if (actionsQueue.length) {
                    context = actionsQueue.shift();
                    context.actionOrdinal = ++actionOrdinal;
                }
                context.executionOrder = ++executionOrder;
                // Add to action traces
                this.actionTraces.push(context);
                this.executionTraces.push((0, utils_1.contextToExecutionTrace)(context));
                (0, utils_1.logExecutionTrace)(this.executionTraces[this.executionTraces.length - 1]);
                // Execute context
                context.receiver.vm.apply(context);
                // Add to local queues
                notificationsQueue = notificationsQueue.concat(context.notificationsQueue);
                if (context.isNotification) {
                    actionsQueue = actionsQueue.concat(context.actionsQueue);
                }
                else {
                    actionsQueue = context.actionsQueue.concat(actionsQueue);
                }
            }
        }
    }
    async applyTransaction(transaction, decodedData) {
        await this.resetTransaction();
        // Take blockchain snapshot
        const snapshot = this.store.snapshot();
        // Take storage snapshot
        if (this.isStorageDeltasEnabled) {
            this.preStorage = this.getStorage();
        }
        try {
            this.applyTransactionActions(transaction, decodedData);
        }
        catch (e) {
            // Revert back to pre-transaction
            this.store.revertTo(snapshot);
            throw e;
        }
        if (this.isStorageDeltasEnabled) {
            this.postStorage = this.getStorage();
            this.setStorageDeltas();
        }
    }
    getAccount(name) {
        return this.accounts[name.toString()];
    }
    createAccount(args) {
        if (typeof args === "string") {
            args = { name: args };
        }
        args.name = eosio_1.Name.from(args.name);
        const account = new account_1.Account({
            ...args,
            bc: this
        });
        this.accounts[account.name.toString()] = account;
        return account;
    }
    /**
     * Create a list of accounts
     * @param {Blockchain} bc - Blockchain - The blockchain that the accounts will be created on.
     * @param {string[]} accounts - An array of account names.
     * @returns An array of accounts.
     */
    createAccounts(...accounts) {
        const createdAccounts = [];
        for (const account of accounts) {
            createdAccounts.push(this.createAccount(account));
        }
        return createdAccounts;
    }
    /**
     * It reads a file from the file system or from the network and returns it as a Uint8Array
     * @param {string} fileName - The name of the file to read.
     * @returns A promise of a Uint8Array.
     */
    async readWasm(fileName) {
        if (!!fs.readFileSync) {
            return fs.readFileSync(fileName);
        }
        else {
            const res = await (0, cross_fetch_1.default)(fileName);
            return new Uint8Array(await res.arrayBuffer());
        }
    }
    /**
    * It reads the contents of a file and returns it as a string.
    * @param {string} fileName - The path to the ABI file.
    * @returns The ABI of the contract.
    */
    async readAbi(fileName) {
        if (!!fs.readFileSync) {
            return fs.readFileSync(fileName, 'utf8');
        }
        else {
            const res = await (0, cross_fetch_1.default)(fileName);
            return res.text();
        }
    }
    /**
    * Create a new account with the given name, wasm, and abi
    * @param {Blockchain} bc - Blockchain - the blockchain to create the contract on
    * @param {NameType} name - Name of the contract.
    * @param {string} folder - The folder name of the contract.
    * @param [enableInline=false] - If true, the contract will send inline. If false, it will send to a new
    * account.
    * @returns The contract account.
    */
    createContract(name, folder, enableInline = true) {
        return this.createAccount({
            name: eosio_1.Name.from(name),
            wasm: this.readWasm(`${folder}.wasm`),
            abi: this.readAbi(`${folder}.abi`),
            enableInline
        });
    }
    /**
     * Time
     */
    setTime(time) {
        this.timestamp = eosio_1.TimePoint.fromMilliseconds(time.toMilliseconds());
    }
    addTime(time) {
        const msToAdd = time.toMilliseconds();
        this.blockNum += msToAdd / 500;
        this.timestamp = eosio_1.TimePoint.fromMilliseconds(this.timestamp.toMilliseconds() + msToAdd);
    }
    subtractTime(time) {
        if (this.timestamp.toMilliseconds() < time.toMilliseconds()) {
            throw new Error(`Blockchain time must not go negative`);
        }
        const msToSub = time.toMilliseconds();
        this.blockNum -= msToSub / 500;
        this.timestamp = eosio_1.TimePoint.fromMilliseconds(this.timestamp.toMilliseconds() - msToSub);
    }
    addBlocks(numberOfBlocks) {
        this.addTime(eosio_1.TimePoint.fromMilliseconds(numberOfBlocks * 500));
    }
    /**
     * Reset
     */
    async resetTransaction() {
        await this.resetVm();
        this.clearConsole();
    }
    async resetVm() {
        this.preStorage = undefined;
        this.postStorage = undefined;
        this._storageDeltas = undefined;
        this.actionTraces = [];
        this.executionTraces = [];
        await Promise.all(Object.values(this.accounts).map(account => account.recreateVm()));
    }
    clearConsole() {
        this.console = '';
    }
    resetTables(store) {
        this.store = store || new table_1.TableStore();
    }
    /**
     * Storage
     */
    get storageDeltas() {
        if (!this.isStorageDeltasEnabled) {
            throw new Error('Storage deltas are not enabled (use enableStorageDeltas)');
        }
        return this._storageDeltas;
    }
    enableStorageDeltas() {
        this.isStorageDeltasEnabled = true;
    }
    disableStorageDeltas() {
        this.isStorageDeltasEnabled = false;
    }
    printStorageDeltas() {
        const stringifyWithBigInt = (json) => JSON.stringify(json, (key, value) => {
            return typeof value === 'bigint' ? value.toString() : value;
        }, 4);
        let storageDeltasJson = stringifyWithBigInt(this.storageDeltas);
        storageDeltasJson = (0, color_1.findStartAndEnd)(storageDeltasJson, `"new":`, colors_1.default.green);
        storageDeltasJson = (0, color_1.findStartAndEnd)(storageDeltasJson, `"old":`, colors_1.default.red);
        console.log(storageDeltasJson);
    }
    getStorage() {
        const indexes = ['idx64', 'idx128', 'idx256', 'idxDouble'];
        const rowsByTable = {};
        const secondaryTableToPrimary = (sec) => {
            if (sec.length === 13) {
                sec = sec.slice(0, -1);
            }
            return sec.replace(/\.+$/, "");
        };
        const convertSecondary = (indexType, value) => {
            const obj = {
                type: indexType,
                value: value
            };
            if (indexType === 'idx64') {
                obj.type = 'idxu64';
            }
            else if (indexType === 'idx128') {
                obj.type = 'idxU128';
                const buf = buffer_1.default.alloc(16);
                vm_1.SecondaryKeyConverter.uint128.to(buf, value);
                obj.rawValue = buf.slice();
            }
            else if (indexType === 'idx256') {
                const convertedValue = vm_1.SecondaryKeyConverter.checksum256.from(value);
                obj.value = eosio_1.Checksum256.from(convertedValue).hexString;
                obj.type = 'idxU256';
            }
            else if (indexType === 'idxDouble') {
                const buf = buffer_1.default.alloc(8);
                buf.writeDoubleLE(value);
                obj.value = buf.readDoubleBE().toString();
                obj.type = 'idxf64';
            }
            return obj;
        };
        // Get all primary rows
        for (const tab of Array.from(this.store.prefixesIndex.values())) {
            const codeName = (0, bn_1.bigIntToName)(tab.code).toString();
            const scopeName = (0, bn_1.bigIntToName)(tab.scope).toString() || '.';
            const tableName = secondaryTableToPrimary((0, bn_1.bigIntToName)(tab.table).toString());
            if (!rowsByTable[codeName]) {
                rowsByTable[codeName] = {};
            }
            if (!rowsByTable[codeName][tableName]) {
                rowsByTable[codeName][tableName] = {};
            }
            if (!rowsByTable[codeName][tableName][scopeName]) {
                rowsByTable[codeName][tableName][scopeName] = [];
            }
            let value = tab.lowerbound(tab.lowestKey());
            while (value) {
                const primaryObj = {
                    primaryKey: value.primaryKey,
                    payer: (0, bn_1.bigIntToName)(value.payer).toString(),
                    value: this.accounts[codeName].tables[tableName](tab.scope).getTableRow(value.primaryKey)
                };
                for (const index of indexes) {
                    const secondaryObj = this.store[index].get({
                        tableId: value.tableId,
                        primaryKey: value.primaryKey
                    });
                    if (secondaryObj) {
                        if (!primaryObj.secondaryIndexes) {
                            primaryObj.secondaryIndexes = [];
                        }
                        primaryObj.secondaryIndexes.push(convertSecondary(index, secondaryObj.secondaryKey));
                    }
                }
                rowsByTable[codeName][tableName][scopeName].push(primaryObj);
                value = tab.next(value.primaryKey);
            }
        }
        return rowsByTable;
    }
    setStorageDeltas() {
        this.storageDeltaChangesets = (0, diff_1.flattenChangeset)((0, diff_1.diff)(this.preStorage, this.postStorage));
        let parsedDiff = {};
        for (const change of this.storageDeltaChangesets) {
            change.path = change.path.slice(2).split('|');
            const [account, table, scope, index] = change.path;
            // console.log(account, table, scope, index, change.type, change.key)
            const fill = (storage) => {
                let path = [];
                if (account) {
                    if (table) {
                        if (scope) {
                            path = [account, table, scope, index];
                            (0, lodash_1.set)(parsedDiff, path, storage[account][table][scope][index]);
                        }
                        else {
                            path = [account, table, change.key];
                            (0, lodash_1.set)(parsedDiff, [account, table, change.key], storage[account][table][change.key]);
                        }
                    }
                    else {
                        path = [account, change.key];
                        (0, lodash_1.set)(parsedDiff, path, storage[account][change.key]);
                    }
                }
                else {
                    path = [change.key];
                    parsedDiff = { ...parsedDiff, ...change.value };
                }
                return path;
            };
            if (change.type === diff_1.Operation.UPDATE) {
                (0, lodash_1.set)(parsedDiff, [account, table, scope, index], this.preStorage[account][table][scope][index]);
                (0, lodash_1.set)(parsedDiff, change.path, {
                    old: change.oldValue,
                    new: change.value
                });
                parsedDiff[account][table][scope] = parsedDiff[account][table][scope].filter(_ => !!_);
            }
            else if (change.type === diff_1.Operation.ADD) {
                const path = fill(this.postStorage);
                (0, lodash_1.set)(parsedDiff, path, { new: change.value });
            }
            else if (change.type === diff_1.Operation.REMOVE) {
                // fill(this.preStorage)
                // set(parsedDiff, change.path, { old: change.value })
            }
        }
        this._storageDeltas = parsedDiff;
    }
}
exports.Blockchain = Blockchain;
//# sourceMappingURL=blockchain.js.map