import { Name, Transaction, TimePoint, TimePointSec, NameType } from "@greymass/eosio";
import { TableStore } from "./table";
import { Account, AccountArgs } from "./account";
import { VM } from "./vm";
import { ExecutionTrace } from "./types";
export declare class Blockchain {
    accounts: {
        [key: string]: Account;
    };
    timestamp: TimePoint;
    blockNum: number;
    store: TableStore;
    console: string;
    actionTraces: VM.Context[];
    executionTraces: ExecutionTrace[];
    protocolFeatures: string[];
    isStorageDeltasEnabled: boolean;
    preStorage: any;
    postStorage: any;
    storageDeltaChangesets: any;
    _storageDeltas: any;
    constructor({ accounts, timestamp, blockNum, store, }?: {
        accounts?: {
            [key: string]: Account;
        };
        timestamp?: TimePoint;
        blockNum?: number;
        store?: TableStore;
    });
    private applyTransactionActions;
    applyTransaction(transaction: Transaction, decodedData?: any): Promise<void>;
    getAccount(name: Name): Account | undefined;
    createAccount(args: string | Omit<AccountArgs, "bc">): Account;
    /**
     * Create a list of accounts
     * @param {Blockchain} bc - Blockchain - The blockchain that the accounts will be created on.
     * @param {string[]} accounts - An array of account names.
     * @returns An array of accounts.
     */
    createAccounts(...accounts: string[]): Account[];
    /**
     * It reads a file from the file system or from the network and returns it as a Uint8Array
     * @param {string} fileName - The name of the file to read.
     * @returns A promise of a Uint8Array.
     */
    readWasm(fileName: string): Promise<Uint8Array>;
    /**
    * It reads the contents of a file and returns it as a string.
    * @param {string} fileName - The path to the ABI file.
    * @returns The ABI of the contract.
    */
    readAbi(fileName: string): Promise<string>;
    /**
    * Create a new account with the given name, wasm, and abi
    * @param {Blockchain} bc - Blockchain - the blockchain to create the contract on
    * @param {NameType} name - Name of the contract.
    * @param {string} folder - The folder name of the contract.
    * @param [enableInline=false] - If true, the contract will send inline. If false, it will send to a new
    * account.
    * @returns The contract account.
    */
    createContract(name: NameType, folder: string, enableInline?: boolean): Account;
    /**
     * Time
     */
    setTime(time: TimePoint | TimePointSec): void;
    addTime(time: TimePoint | TimePointSec): void;
    subtractTime(time: TimePoint | TimePointSec): void;
    addBlocks(numberOfBlocks: number): void;
    /**
     * Reset
     */
    resetTransaction(): Promise<void>;
    resetVm(): Promise<void>;
    clearConsole(): void;
    resetTables(store?: TableStore): void;
    /**
     * Storage
     */
    get storageDeltas(): any;
    enableStorageDeltas(): void;
    disableStorageDeltas(): void;
    printStorageDeltas(): void;
    getStorage(): {};
    private setStorageDeltas;
}
