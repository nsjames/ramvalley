"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableView = exports.TableStore = exports.SecondaryKeyStore = exports.IndexObject = exports.KeyValueObject = exports.Table = void 0;
const store_1 = require("../store");
const vert_1 = require("../vert");
const sorted_btree_1 = __importDefault(require("sorted-btree"));
const eosio_1 = require("@greymass/eosio");
const buffer_1 = __importDefault(require("../buffer"));
const bn_1 = require("./bn");
const bn_js_1 = __importDefault(require("bn.js"));
class KeyValueObject {
    constructor(args) {
        this.id = 0;
        Object.assign(this, args);
    }
    clone() {
        const kv = new KeyValueObject({
            id: this.id,
            tableId: this.tableId,
            primaryKey: this.primaryKey,
            payer: this.payer,
            value: this.value
        });
        return kv;
    }
}
exports.KeyValueObject = KeyValueObject;
class Table extends store_1.PrefixedStore {
    static serializePrefix(code, scope, table) {
        let buf = buffer_1.default.alloc(24);
        buf.writeBigUInt64BE(code);
        buf.writeBigUInt64BE(scope, 8);
        buf.writeBigUInt64BE(table, 16);
        return buf;
    }
    static bigintToBuffer(v) {
        const buffer = buffer_1.default.alloc(8);
        buffer.writeBigUInt64BE(v);
        return buffer;
    }
    constructor(store, options) {
        super(store, options);
        this.seq = 0;
        this._size = 0;
        this._code = options.code;
        this._scope = options.scope;
        this._table = options.table;
        this.payer = options.payer;
        this._prefix = options.prefix;
    }
    get code() {
        return this._code;
    }
    get scope() {
        return this._scope;
    }
    get table() {
        return this._table;
    }
    get size() {
        return this._size;
    }
    prefix() {
        if (!this._prefix) {
            this._prefix = Table.serializePrefix(this.code, this.scope, this.table);
        }
        return this._prefix;
    }
    key(key) {
        return buffer_1.default.concat([this.prefix(), Table.bigintToBuffer(key)]);
    }
    lowestKey() {
        return 0n;
    }
    highestKey() {
        return 18446744073709551615n;
    }
    parsePrefix(key) {
        return key.slice(0, 24);
    }
    set(key, value) {
        const prev = this.get(key);
        super.set(key, value);
        if (!prev) {
            value.id = this.seq++;
            this._size++;
        }
    }
    delete(key) {
        super.delete(key);
        this._size--;
        if (this._size === 0) {
            this.store.deletePrefix(this.prefix());
        }
    }
    has(key) {
        return !!this.get(key);
    }
    revert(change) {
        if (change instanceof store_1.CreateItemChange) {
            this.seq--;
            this._size--;
        }
        else if (change instanceof store_1.DeleteItemChange) {
            this._size++;
        }
    }
}
exports.Table = Table;
class IndexObject {
    constructor(args) {
        Object.assign(this, args);
    }
    static compareTable(a, b) {
        return (a.tableId < b.tableId) ? -1 : (a.tableId > b.tableId) ? 1 : 0;
    }
    static compare(a, b) {
        const tableComparison = IndexObject.compareTable(a, b);
        const differentTable = tableComparison !== 0;
        if (differentTable) {
            return tableComparison;
        }
        const ignorePrimaryKey = a.ignorePrimaryKey || b.ignorePrimaryKey;
        const samePrimaryKey = a.primaryKey === b.primaryKey;
        if (ignorePrimaryKey || samePrimaryKey) {
            return 0;
        }
        return (a.primaryKey < b.primaryKey) ? -1 : 1;
    }
    static comparePrimitives(a, b) {
        const tableComparison = IndexObject.compareTable(a, b);
        const differentTable = tableComparison !== 0;
        if (differentTable) {
            return tableComparison;
        }
        const sameSecondaryKey = a.secondaryKey === b.secondaryKey;
        if (sameSecondaryKey) {
            return IndexObject.compare(a, b);
        }
        return (a.secondaryKey < b.secondaryKey) ? -1 : 1;
    }
    static compareBuffer(a, b) {
        const tableComparison = IndexObject.compareTable(a, b);
        const sameTable = tableComparison === 0;
        if (!sameTable) {
            return tableComparison;
        }
        const bufferComparison = buffer_1.default.compare(a.secondaryKey, b.secondaryKey);
        const sameBuffer = bufferComparison === 0;
        if (!sameBuffer) {
            return bufferComparison;
        }
        return IndexObject.compare(a, b);
    }
    clone() {
        const obj = { ...this };
        if (obj.secondaryKey instanceof Uint8Array) {
            obj.secondaryKey = obj.secondaryKey.slice();
        }
        return new IndexObject(obj);
    }
}
exports.IndexObject = IndexObject;
class SecondaryKeyStore {
    constructor(parent, comparePrimary, compareSecondary) {
        this.parent = parent;
        this.secondary = {
            lowest: undefined,
            highest: undefined,
            get: (key) => {
                return this.bySecondary.get(key);
            },
            penultimate: (tableId) => {
                const highestKey = {
                    tableId,
                    primaryKey: BigInt.asUintN(64, -1n),
                    secondaryKey: this.secondary.highest,
                };
                const idx = this.secondary.get(highestKey);
                if (idx) {
                    return idx;
                }
                return this.secondary.prev(highestKey);
            },
            lowerbound: (key) => {
                if (this.bySecondary.has(key)) {
                    return this.bySecondary.get(key);
                }
                return this.secondary.next(key);
            },
            upperbound: (key) => {
                return this.secondary.next(key);
            },
            prev: (key) => {
                const kv = this.bySecondary.nextLowerPair(key);
                if (kv) {
                    const [_, value] = kv;
                    if (value.tableId === key.tableId) {
                        return value;
                    }
                }
                return;
            },
            next: (key) => {
                const kv = this.bySecondary.nextHigherPair(key);
                if (kv) {
                    const [_, value] = kv;
                    if (value.tableId === key.tableId) {
                        return value;
                    }
                }
                return;
            },
        };
        this.byPrimary = new sorted_btree_1.default(undefined, comparePrimary);
        this.bySecondary = new sorted_btree_1.default(undefined, compareSecondary);
    }
    get(key) {
        return this.byPrimary.get(key);
    }
    set(key, newKey, isReverting = false) {
        if (key && this.bySecondary.has(key)) {
            if (!isReverting) {
                this.parent.pushChanges(new UpdateSecondaryKeyChange({
                    key: this.bySecondary.get(key), newKey: newKey, keystore: this
                }));
            }
            this.bySecondary.delete(key);
        }
        else if (!isReverting) {
            this.parent.pushChanges(new CreateSecondaryKeyChange({ key: newKey, keystore: this }));
        }
        this.bySecondary.set(newKey, newKey);
        this.byPrimary.set(newKey, newKey);
    }
    delete(key, isReverting = false) {
        if (!isReverting) {
            this.parent.pushChanges(new DeleteSecondaryKeyChange({ key: this.byPrimary.get(key), keystore: this }));
        }
        this.bySecondary.delete(key);
        this.byPrimary.delete(key);
    }
    next(key) {
        const kv = this.byPrimary.nextHigherPair(key);
        if (kv) {
            const [_, value] = kv;
            if (value.tableId === key.tableId) {
                return value;
            }
        }
        return;
    }
    lowerbound(key) {
        if (this.byPrimary.has(key)) {
            return this.byPrimary.get(key);
        }
        return this.next(key);
    }
    upperbound(key) {
        return this.next(key);
    }
}
exports.SecondaryKeyStore = SecondaryKeyStore;
class Index64 extends SecondaryKeyStore {
    constructor(store) {
        super(store, IndexObject.compare, IndexObject.comparePrimitives);
        this.secondary.lowest = 0n;
        this.secondary.highest = BigInt.asUintN(64, -1n);
    }
}
class Index128 extends SecondaryKeyStore {
    constructor(store) {
        super(store, IndexObject.compare, IndexObject.comparePrimitives);
        this.secondary.lowest = 0n;
        this.secondary.highest = BigInt.asUintN(128, -1n);
    }
}
class Index256 extends SecondaryKeyStore {
    constructor(store) {
        super(store, IndexObject.compare, IndexObject.compareBuffer);
        this.secondary.lowest = buffer_1.default.alloc(32, 0);
        this.secondary.highest = buffer_1.default.alloc(32, 255);
    }
}
class IndexDouble extends SecondaryKeyStore {
    constructor(store) {
        super(store, IndexObject.compare, IndexObject.comparePrimitives);
        this.secondary.lowest = 0;
        this.secondary.highest = Number.MAX_VALUE;
    }
}
class CreateSecondaryKeyChange {
    constructor(init) {
        Object.assign(this, init);
    }
    revert(store) {
        vert_1.log.debug(`revert secondary key ${this.key.primaryKey} creation.`);
        if (!this.keystore.get(this.key)) {
            throw new Error('revert stack is corrupted');
        }
        this.keystore.delete(this.key, true);
    }
}
class UpdateSecondaryKeyChange {
    constructor(init) {
        Object.assign(this, init);
    }
    revert(store) {
        vert_1.log.debug('revert secondary key update');
        if (!this.keystore.get(this.newKey)) {
            throw new Error('revert stack is corrupted');
        }
        this.keystore.set(this.newKey, this.key, true);
    }
}
class DeleteSecondaryKeyChange {
    constructor(init) {
        Object.assign(this, init);
    }
    revert(store) {
        vert_1.log.debug('revert secondary key deletion');
        if (this.keystore.get(this.key)) {
            throw new Error('revert stack is corrupted');
        }
        this.keystore.set(undefined, this.key, true);
    }
}
class TableStore extends store_1.Store {
    // private idxLongDouble;
    constructor(Prefix = Table) {
        super(Prefix);
        this.idx64 = new Index64(this);
        this.idx128 = new Index128(this);
        this.idx256 = new Index256(this);
        this.idxDouble = new IndexDouble(this);
    }
    createTable(code, scope, table, payer) {
        const prefix = Table.serializePrefix(code, scope, table);
        const tab = this.createPrefix(Table.serializePrefix(code, scope, table), {
            code, scope, table, payer, prefix,
        });
        return tab;
    }
    findTable(code, scope, table) {
        return this.getPrefix(Table.serializePrefix(code, scope, table));
    }
    getTableById(id) {
        return this.getPrefixById(id);
    }
}
exports.TableStore = TableStore;
class TableView {
    constructor(tab, abi, bc) {
        this.tab = tab;
        this.abi = abi;
        this.bc = bc;
        this.name = eosio_1.Name.from(eosio_1.UInt64.from((0, bn_1.bigIntToBn)(this.tab.table))).toString();
        this.type = this.abi.tables.find((table) => table.name === this.name);
    }
    get(primaryKey) {
        const kv = this.tab.get(primaryKey);
        if (kv) {
            return eosio_1.Serializer.decode({
                abi: this.abi,
                data: kv.value,
                type: this.type,
            });
        }
        return;
    }
    set(primaryKey, payer, tableData) {
        const type = this.abi.tables.find((table) => table.name === this.name);
        if (!type) {
            throw new Error(`Table ${this.name} not found in ABI`);
        }
        const value = eosio_1.Serializer.encode({
            abi: this.abi,
            type: this.type,
            object: tableData
        }).array;
        const kv = new KeyValueObject({
            tableId: this.tab.id,
            primaryKey,
            payer: (0, bn_1.nameToBigInt)(payer),
            value,
        });
        this.tab.set(primaryKey, kv);
    }
    getTableRow(primaryKey) {
        if (bn_js_1.default.isBN(primaryKey)) {
            primaryKey = (0, bn_1.bnToBigInt)(primaryKey);
        }
        const value = this.get(primaryKey);
        if (value) {
            return eosio_1.Serializer.objectify(value);
        }
    }
    getTableRows(lowerBound = BigInt(0), options = {}) {
        if (bn_js_1.default.isBN(lowerBound)) {
            lowerBound = (0, bn_1.bnToBigInt)(lowerBound);
        }
        const rows = [];
        let kvNext = this.bc.store.getTableById(this.tab.id).lowerbound(lowerBound);
        while (kvNext) {
            rows.push(this.getTableRow(kvNext.primaryKey));
            if (options.limit && rows.length >= options.limit) {
                break;
            }
            kvNext = this.bc.store.getTableById(this.tab.id).next(kvNext.primaryKey);
        }
        return rows;
    }
}
exports.TableView = TableView;
//# sourceMappingURL=table.js.map