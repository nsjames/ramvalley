"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeleteItemChange = exports.UpdateItemChange = exports.CreateItemChange = exports.DeletePrefixChange = exports.CreatePrefixChange = exports.Store = exports.PrefixedStore = void 0;
const sorted_btree_1 = __importStar(require("sorted-btree"));
const vert_1 = require("./vert");
const buffer_1 = __importDefault(require("./buffer"));
function defaultComparator(a, b) {
    if (buffer_1.default.isBuffer(a) && buffer_1.default.isBuffer(b)) {
        return buffer_1.default.compare(a, b);
    }
    return (0, sorted_btree_1.defaultComparator)(a, b);
}
class PrefixedStore {
    set(key, value) {
        this.store.set(this.key(key), value, this);
    }
    get(key) {
        return this.store.get(this.key(key));
    }
    delete(key) {
        this.store.delete(this.key(key));
    }
    revert(change) { }
    prev(key) {
        const found = this.store.prev(this.key(key));
        if (found) {
            const [key, value] = found;
            if (!defaultComparator(this.prefix(), this.parsePrefix(key))) {
                return value;
            }
        }
        return;
    }
    next(key) {
        const found = this.store.next(this.key(key));
        if (found) {
            const [key, value] = found;
            if (!defaultComparator(this.prefix(), this.parsePrefix(key))) {
                return value;
            }
        }
        return;
    }
    lowerbound(key) {
        if (this.store.has(this.key(key))) {
            return this.store.get(this.key(key));
        }
        return this.next(key);
    }
    upperbound(key) {
        return this.next(key);
    }
    penultimate() {
        const key = this.key(this.highestKey());
        if (this.store.has(key)) {
            return this.store.get(key);
        }
        const kv = this.store.prev(key);
        if (kv) {
            const [key, value] = kv;
            if (!defaultComparator(this.prefix(), this.parsePrefix(key))) {
                return value;
            }
        }
        return;
    }
    constructor(store, options) {
        this.store = store;
    }
}
exports.PrefixedStore = PrefixedStore;
class Store {
    constructor(Prefix, compare = defaultComparator) {
        this.Prefix = Prefix;
        this.prefixes = new sorted_btree_1.default(undefined, defaultComparator);
        this.prefixesIndex = new Map();
        this.changes = new Array();
        this.isReverting = false;
        this._seq = 0;
        this.store = new sorted_btree_1.default(undefined, compare);
    }
    set seq(seq) {
        if (!this.isReverting) {
            throw new Error('do not access');
        }
        this._seq = seq;
    }
    get seq() {
        return this._seq;
    }
    createPrefix(prefix, options) {
        let prefixedStore = this.prefixes.get(prefix);
        if (prefixedStore) {
            throw new Error('prefix uniqueness violation');
        }
        this.changes.push(new CreatePrefixChange({ prefix }));
        prefixedStore = new this.Prefix(this, options);
        prefixedStore.id = this._seq++;
        this.prefixes.set(prefix, prefixedStore);
        this.prefixesIndex.set(prefixedStore.id, prefixedStore);
        return prefixedStore;
    }
    deletePrefix(prefix) {
        let prefixedStore = this.prefixes.get(prefix);
        if (!prefixedStore) {
            throw new Error('non-existent prefix');
        }
        this.changes.push(new DeletePrefixChange({ prefixedStore }));
        this.prefixesIndex.delete(prefixedStore.id);
        this.prefixes.delete(prefix);
    }
    getPrefix(prefix) {
        return this.prefixes.get(prefix);
    }
    getPrefixById(id) {
        return this.prefixesIndex.get(id);
    }
    set(key, value, prefixedStorage) {
        const prev = this.store.get(key);
        if (prev) {
            this.changes.push(new UpdateItemChange({ key, value: prev }));
        }
        else {
            this.changes.push(new CreateItemChange({ key, prefixedStorage }));
        }
        this.store.set(key, value);
    }
    get(key) {
        return this.store.get(key);
    }
    has(key) {
        return this.store.has(key);
    }
    delete(key) {
        let value = this.store.get(key);
        if (!value) {
            throw new Error('try deleting non-existent item');
        }
        this.changes.push(new DeleteItemChange({ key, value }));
        this.store.delete(key);
    }
    prev(key) {
        return this.store.nextLowerPair(key);
    }
    next(key) {
        return this.store.nextHigherPair(key);
    }
    snapshot() {
        return this.changes.length;
    }
    revertTo(snapshot = 0) {
        this.isReverting = true;
        const store = {
            store: this,
            internal: this.store,
            prefixes: this.prefixes,
            prefixesIndex: this.prefixesIndex,
        };
        for (let i = this.changes.length - 1; i >= snapshot; --i) {
            this.changes[i].revert(store);
        }
        this.changes = this.changes.slice(0, snapshot);
        this.isReverting = false;
    }
    pushChanges(...changes) {
        this.changes.push(...changes);
    }
}
exports.Store = Store;
class CreatePrefixChange {
    constructor(init) {
        Object.assign(this, init);
    }
    revert(store) {
        vert_1.log.debug('revert prefix creation');
        let prefixedStore = store.store.getPrefix(this.prefix);
        if (!prefixedStore) {
            throw new Error('revert stack is corrupted');
        }
        store.prefixesIndex.delete(prefixedStore.id);
        store.prefixes.delete(this.prefix);
        store.store.seq--;
    }
}
exports.CreatePrefixChange = CreatePrefixChange;
class DeletePrefixChange {
    constructor(init) {
        Object.assign(this, init);
    }
    revert(store) {
        vert_1.log.debug('revert prefix deletion');
        let prefixedStore = store.store.getPrefix(this.prefixedStore.prefix());
        if (prefixedStore) {
            throw new Error('revert stack is corrupted');
        }
        store.prefixes.set(this.prefixedStore.prefix(), this.prefixedStore);
        store.prefixesIndex.set(this.prefixedStore.id, this.prefixedStore);
    }
}
exports.DeletePrefixChange = DeletePrefixChange;
class CreateItemChange {
    constructor(init) {
        Object.assign(this, init);
    }
    revert(store) {
        vert_1.log.debug('revert item creation');
        if (!store.internal.delete(this.key)) {
            throw new Error('revert stack is corrupted');
        }
        if (this.prefixedStorage) {
            this.prefixedStorage.revert(this);
        }
    }
}
exports.CreateItemChange = CreateItemChange;
class UpdateItemChange {
    constructor(init) {
        Object.assign(this, init);
    }
    revert(store) {
        vert_1.log.debug('revert item update');
        if (!store.internal.has(this.key)) {
            throw new Error('revert stack is corrupted');
        }
        store.internal.set(this.key, this.value);
    }
}
exports.UpdateItemChange = UpdateItemChange;
class DeleteItemChange {
    constructor(init) {
        Object.assign(this, init);
    }
    revert(store) {
        vert_1.log.debug('revert item deletion');
        if (store.internal.has(this.key)) {
            throw new Error('revert stack is corrupted');
        }
        store.internal.set(this.key, this.value);
    }
}
exports.DeleteItemChange = DeleteItemChange;
//# sourceMappingURL=store.js.map